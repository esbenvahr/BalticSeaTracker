{"ast":null,"code":"var _jsxFileName = \"/Users/esbenvahr/Desktop/NEW FINAL/app/src/components/BalticSeaTracker.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState, useRef, useCallback, useMemo, memo } from 'react';\nimport { Info, Ship, Menu, ZoomIn, ZoomOut, Radar, Waves, Layers, Wind } from 'lucide-react';\nimport '../styles/palantir-theme.css';\nimport { GoogleMap, useJsApiLoader, Marker, Circle, Polyline, Polygon } from '@react-google-maps/api';\n\n// Add basic CSS styles\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst styles = {\n  container: {\n    display: 'flex',\n    flexDirection: 'column',\n    height: '100vh',\n    backgroundColor: '#121212'\n  },\n  map: {\n    width: '100%',\n    height: '100vh'\n  },\n  sidebar: {\n    width: '320px',\n    backgroundColor: '#1E1E1E',\n    color: '#FFFFFF',\n    padding: '16px',\n    overflowY: 'auto'\n  },\n  controlPanel: {\n    marginBottom: '16px',\n    padding: '12px',\n    backgroundColor: '#252525',\n    borderRadius: '4px'\n  },\n  buttonActive: {\n    backgroundColor: '#3D85C6',\n    color: 'white',\n    padding: '8px 12px',\n    borderRadius: '4px',\n    border: 'none',\n    marginBottom: '8px',\n    cursor: 'pointer',\n    display: 'flex',\n    alignItems: 'center'\n  },\n  button: {\n    backgroundColor: '#444444',\n    color: 'white',\n    padding: '8px 12px',\n    borderRadius: '4px',\n    border: 'none',\n    marginBottom: '8px',\n    cursor: 'pointer',\n    display: 'flex',\n    alignItems: 'center'\n  },\n  heading: {\n    fontSize: '16px',\n    fontWeight: 'bold',\n    marginBottom: '8px',\n    color: '#3D85C6'\n  },\n  footer: {\n    backgroundColor: '#1E1E1E',\n    color: '#888888',\n    padding: '8px',\n    textAlign: 'center',\n    fontSize: '14px'\n  }\n};\n\n// Memoized components for better performance\nconst MemoizedMarker = /*#__PURE__*/memo(Marker);\n_c = MemoizedMarker;\nconst MemoizedCircle = /*#__PURE__*/memo(Circle);\n_c2 = MemoizedCircle;\nconst MemoizedPolygon = /*#__PURE__*/memo(Polygon);\n_c3 = MemoizedPolygon;\nconst MemoizedPolyline = /*#__PURE__*/memo(Polyline);\n\n// Define container style\n_c4 = MemoizedPolyline;\nconst mapContainerStyle = {\n  width: '100%',\n  height: '100vh'\n};\n\n// Define center for the Baltic Sea\nconst defaultCenter = {\n  lat: 59,\n  lng: 19\n};\nconst BalticSeaTracker = () => {\n  _s();\n  // Use the same API key and configuration that worked in SimpleMap\n  const {\n    isLoaded,\n    loadError\n  } = useJsApiLoader({\n    id: 'google-map-script',\n    googleMapsApiKey: 'AIzaSyAl-iGmFThUduVpLpE7sQTmniBSUPtzJjA',\n    libraries: ['geometry', 'drawing']\n  });\n  console.log(\"Map loading status:\", {\n    isLoaded,\n    loadError\n  });\n  const [vessels, setVessels] = useState([]);\n  const [selectedVessel, setSelectedVessel] = useState(null);\n  const [filter, setFilter] = useState('all');\n  const [showSidebar, setShowSidebar] = useState(true);\n  const [displayMode, setDisplayMode] = useState('radar'); // 'radar', 'sonar', or 'fused'\n  const [showWindFarms, setShowWindFarms] = useState(false);\n  const [showRadarCoverage, setShowRadarCoverage] = useState(false); // New state for radar coverage\n  const [showVesselRadar, setShowVesselRadar] = useState(false); // State for vessel radar coverage (300-2999 GT)\n  const [showLargeVesselRadar, setShowLargeVesselRadar] = useState(false); // New state for large vessel radar (>3000 GT)\n  const [mapBounds, setMapBounds] = useState(null); // Track current map bounds\n  const [currentZoom, setCurrentZoom] = useState(6); // Track current zoom level\n  const [mapKey, setMapKey] = useState(Date.now()); // Add key to force remount of map components\n  const [simulationEnabled, setSimulationEnabled] = useState(false); // Track if vessel movement simulation is enabled\n  const [simulationSpeed, setSimulationSpeed] = useState(10); // Simulation speed multiplier (default 10x)\n  const [seaMeshSimulationEnabled, setSeaMeshSimulationEnabled] = useState(false); // Track if SeaMesh simulation is enabled\n  const [simulationStep, setSimulationStep] = useState(0); // Track the current step of the SeaMesh simulation\n  const [warships, setWarships] = useState([]); // Russian warships for the simulation\n  const [detectionRings, setDetectionRings] = useState([]); // Detection events for visualization\n  const animationFrameRef = useRef(null); // Reference to store animation frame ID\n  const lastUpdateTimeRef = useRef(Date.now()); // Reference to store last update time\n  const seaMeshAnimationRef = useRef(null); // Reference for the SeaMesh animation timer\n\n  const zoomRef = useRef(null);\n  const mapRef = useRef(null);\n\n  // Google Maps settings\n  const mapCenter = defaultCenter; // Use the default center\n  const mapZoom = 6;\n\n  // Add state to track current map center\n  const [currentMapCenter, setCurrentMapCenter] = useState(defaultCenter);\n\n  // Memoize map style to prevent recalculations\n  const mapStyle = useMemo(() => getMapStyle(displayMode), [displayMode]);\n  const mapOptions = useMemo(() => ({\n    disableDefaultUI: true,\n    zoomControl: false,\n    styles: mapStyle,\n    draggable: true,\n    // Ensure map is draggable\n    // Hide cities with population under 5000\n    restrictions: {\n      latLngBounds: {\n        north: 66.0,\n        south: 54.0,\n        east: 30.0,\n        west: 9.0\n      }\n    }\n  }), [mapStyle]);\n\n  // Create a ref to track if Google Maps loaded\n  const mapsLoadedRef = useRef(false);\n\n  // Log any errors with Google Maps loading\n  useEffect(() => {\n    if (loadError) {\n      console.error('Error loading Google Maps:', loadError);\n    }\n    if (isLoaded && !mapsLoadedRef.current) {\n      console.log('Google Maps API loaded successfully');\n      mapsLoadedRef.current = true;\n    }\n  }, [isLoaded, loadError]);\n\n  // Initialize vessels with mock data\n  useEffect(() => {\n    if (vessels.length === 0) {\n      console.log(\"Initializing mock vessels\");\n      const mockVessels = Array(20).fill(null).map((_, index) => ({\n        id: `mock-vessel-${index}`,\n        name: `Mock Vessel ${index}`,\n        type: ['commercial', 'tanker', 'passenger', 'military'][index % 4],\n        isRussian: index % 5 === 0,\n        position: [\n        // Random positions in the Baltic Sea\n        19 + (Math.random() * 2 - 1),\n        // longitude\n        59 + (Math.random() * 2 - 1) // latitude\n        ],\n        heading: Math.random() * 360,\n        speed: 10 + Math.random() * 10,\n        flag: index % 5 === 0 ? 'Russia' : 'Sweden',\n        grossTonnage: 300 + Math.floor(Math.random() * 5000)\n      }));\n      setVessels(mockVessels);\n      console.log(\"Mock vessels initialized:\", mockVessels.length);\n    }\n  }, [vessels.length]);\n\n  // Function to get map style based on display mode\n  function getMapStyle(mode) {\n    switch (mode) {\n      case 'radar':\n        return [{\n          elementType: \"geometry\",\n          stylers: [{\n            color: \"#212121\"\n          }]\n        }, {\n          elementType: \"labels.text.stroke\",\n          stylers: [{\n            color: \"#212121\"\n          }]\n        }, {\n          elementType: \"labels.text.fill\",\n          stylers: [{\n            color: \"#746855\"\n          }]\n        }, {\n          featureType: \"water\",\n          elementType: \"geometry\",\n          stylers: [{\n            color: \"#181818\"\n          }]\n        }, {\n          featureType: \"water\",\n          elementType: \"labels.text.fill\",\n          stylers: [{\n            color: \"#3d3d3d\"\n          }]\n        }, {\n          featureType: \"poi\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        }, {\n          featureType: \"transit\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        }, {\n          featureType: \"road\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        },\n        // Hide smaller cities/towns\n        {\n          featureType: \"administrative.locality\",\n          elementType: \"labels\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        },\n        // Only show major cities\n        {\n          featureType: \"administrative.locality\",\n          elementType: \"labels\",\n          filter: [\">=\", [\"get\", \"population\"], 10000],\n          stylers: [{\n            visibility: \"on\"\n          }]\n        }];\n      case 'sonar':\n        return [{\n          elementType: \"geometry\",\n          stylers: [{\n            color: \"#003545\"\n          }]\n        }, {\n          elementType: \"labels.text.stroke\",\n          stylers: [{\n            color: \"#003545\"\n          }]\n        }, {\n          elementType: \"labels.text.fill\",\n          stylers: [{\n            color: \"#00C8FF\"\n          }]\n        }, {\n          featureType: \"water\",\n          elementType: \"geometry\",\n          stylers: [{\n            color: \"#001E29\"\n          }]\n        }, {\n          featureType: \"water\",\n          elementType: \"labels.text.fill\",\n          stylers: [{\n            color: \"#00E5FF\"\n          }]\n        }, {\n          featureType: \"poi\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        }, {\n          featureType: \"transit\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        }, {\n          featureType: \"road\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        },\n        // Hide smaller cities/towns\n        {\n          featureType: \"administrative.locality\",\n          elementType: \"labels\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        },\n        // Only show major cities\n        {\n          featureType: \"administrative.locality\",\n          elementType: \"labels\",\n          filter: [\">=\", [\"get\", \"population\"], 10000],\n          stylers: [{\n            visibility: \"on\"\n          }]\n        }];\n      case 'fused':\n        return [{\n          elementType: \"geometry\",\n          stylers: [{\n            color: \"#142639\"\n          }]\n        }, {\n          elementType: \"labels.text.stroke\",\n          stylers: [{\n            color: \"#142639\"\n          }]\n        }, {\n          elementType: \"labels.text.fill\",\n          stylers: [{\n            color: \"#3D85C6\"\n          }]\n        }, {\n          featureType: \"water\",\n          elementType: \"geometry\",\n          stylers: [{\n            color: \"#0A1C2A\"\n          }]\n        }, {\n          featureType: \"water\",\n          elementType: \"labels.text.fill\",\n          stylers: [{\n            color: \"#4a90e2\"\n          }]\n        }, {\n          featureType: \"poi\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        }, {\n          featureType: \"transit\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        }, {\n          featureType: \"road\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        },\n        // Hide smaller cities/towns\n        {\n          featureType: \"administrative.locality\",\n          elementType: \"labels\",\n          stylers: [{\n            visibility: \"off\"\n          }]\n        },\n        // Only show major cities\n        {\n          featureType: \"administrative.locality\",\n          elementType: \"labels\",\n          filter: [\">=\", [\"get\", \"population\"], 10000],\n          stylers: [{\n            visibility: \"on\"\n          }]\n        }];\n      default:\n        return [];\n    }\n  }\n\n  // Function to generate a random coordinate within Baltic Sea\n  const randomCoordinate = () => {\n    // Areas to avoid - major inland lakes and problematic areas\n    const avoidAreas = [\n    // Swedish lakes\n    {\n      minLat: 58.0,\n      maxLat: 59.3,\n      minLng: 12.3,\n      maxLng: 14.0\n    },\n    // Vänern\n    {\n      minLat: 57.7,\n      maxLat: 58.7,\n      minLng: 14.0,\n      maxLng: 14.8\n    },\n    // Vättern\n    {\n      minLat: 59.1,\n      maxLat: 59.7,\n      minLng: 15.8,\n      maxLng: 18.0\n    },\n    // Mälaren\n\n    // Finnish lakes\n    {\n      minLat: 61.0,\n      maxLat: 62.3,\n      minLng: 24.5,\n      maxLng: 26.4\n    },\n    // Päijänne\n    {\n      minLat: 61.3,\n      maxLat: 63.1,\n      minLng: 26.5,\n      maxLng: 29.0\n    },\n    // Saimaa\n\n    // Other inland waters to avoid\n    {\n      minLat: 60.0,\n      maxLat: 61.8,\n      minLng: 29.2,\n      maxLng: 32.0\n    },\n    // Ladoga\n    {\n      minLat: 57.8,\n      maxLat: 59.0,\n      minLng: 26.5,\n      maxLng: 28.5\n    },\n    // Peipus\n\n    // Problematic shore areas - Northern Sweden west coast\n    {\n      minLat: 60.0,\n      maxLat: 65.0,\n      minLng: 17.0,\n      maxLng: 19.5\n    },\n    // Problematic shore areas - Northern Finland west coast\n    {\n      minLat: 63.0,\n      maxLat: 65.5,\n      minLng: 22.5,\n      maxLng: 25.0\n    }];\n\n    // Combine shipping lanes with wider dispersal areas\n    const shippingLanes = [\n    // Main shipping lanes (lower weight than before to reduce clustering)\n    // Danish Straits to St. Petersburg\n    {\n      minLat: 54.5,\n      maxLat: 55.2,\n      minLng: 10.8,\n      maxLng: 13.0,\n      weight: 5\n    },\n    // Danish Straits entrance\n    {\n      minLat: 55.0,\n      maxLat: 55.8,\n      minLng: 12.8,\n      maxLng: 14.5,\n      weight: 4\n    },\n    // Route east of Denmark\n    {\n      minLat: 55.3,\n      maxLat: 56.2,\n      minLng: 14.5,\n      maxLng: 16.5,\n      weight: 4\n    },\n    // Southern Sweden coast\n    {\n      minLat: 55.0,\n      maxLat: 56.0,\n      minLng: 16.5,\n      maxLng: 18.5,\n      weight: 3\n    },\n    // Midway to Gotland\n    {\n      minLat: 57.0,\n      maxLat: 58.2,\n      minLng: 18.5,\n      maxLng: 20.0,\n      weight: 4\n    },\n    // North of Gotland\n    {\n      minLat: 58.5,\n      maxLat: 59.5,\n      minLng: 20.0,\n      maxLng: 22.0,\n      weight: 3\n    },\n    // Approach to Gulf of Finland\n    {\n      minLat: 59.2,\n      maxLat: 59.8,\n      minLng: 22.0,\n      maxLng: 24.5,\n      weight: 5\n    },\n    // Gulf of Finland western part\n    {\n      minLat: 59.7,\n      maxLat: 60.2,\n      minLng: 24.5,\n      maxLng: 28.0,\n      weight: 4\n    },\n    // Gulf of Finland eastern part\n\n    // Port approaches - reduced weights to prevent clustering\n    {\n      minLat: 60.0,\n      maxLat: 60.5,\n      minLng: 24.5,\n      maxLng: 25.0,\n      weight: 3\n    },\n    // Helsinki\n    {\n      minLat: 60.2,\n      maxLat: 60.5,\n      minLng: 22.0,\n      maxLng: 22.5,\n      weight: 3\n    },\n    // Turku\n    {\n      minLat: 55.3,\n      maxLat: 56.3,\n      minLng: 12.5,\n      maxLng: 13.0,\n      weight: 3\n    },\n    // Malmö\n    {\n      minLat: 58.5,\n      maxLat: 59.5,\n      minLng: 16.5,\n      maxLng: 18.5,\n      weight: 3\n    },\n    // Stockholm\n    {\n      minLat: 54.3,\n      maxLat: 54.8,\n      minLng: 18.3,\n      maxLng: 19.0,\n      weight: 3\n    },\n    // Gdańsk\n    {\n      minLat: 54.0,\n      maxLat: 54.5,\n      minLng: 13.0,\n      maxLng: 14.5,\n      weight: 3\n    },\n    // Rostock\n\n    // Wider dispersal areas - these ensure ships are spread throughout the entire sea\n    // Central Baltic - large dispersal areas\n    {\n      minLat: 56.0,\n      maxLat: 58.0,\n      minLng: 17.0,\n      maxLng: 20.0,\n      weight: 5\n    },\n    // Central Baltic wider area\n    {\n      minLat: 57.5,\n      maxLat: 59.5,\n      minLng: 19.0,\n      maxLng: 22.0,\n      weight: 5\n    },\n    // Eastern Baltic wider area\n\n    // Gulf of Bothnia - more dispersed\n    {\n      minLat: 60.0,\n      maxLat: 62.0,\n      minLng: 18.0,\n      maxLng: 21.0,\n      weight: 4\n    },\n    // Southern Bothnia dispersed\n    {\n      minLat: 62.0,\n      maxLat: 65.0,\n      minLng: 18.0,\n      maxLng: 23.0,\n      weight: 3\n    },\n    // Northern Bothnia dispersed\n\n    // Western Baltic - more dispersed\n    {\n      minLat: 54.0,\n      maxLat: 56.0,\n      minLng: 12.0,\n      maxLng: 15.0,\n      weight: 4\n    },\n    // Western Baltic dispersed\n    {\n      minLat: 54.0,\n      maxLat: 57.0,\n      minLng: 15.0,\n      maxLng: 18.0,\n      weight: 5\n    },\n    // South-central Baltic dispersed\n\n    // Other dispersed areas to ensure wider coverage\n    {\n      minLat: 54.0,\n      maxLat: 55.5,\n      minLng: 18.0,\n      maxLng: 20.0,\n      weight: 3\n    },\n    // Southern Baltic dispersed\n    {\n      minLat: 56.5,\n      maxLat: 58.0,\n      minLng: 15.0,\n      maxLng: 17.0,\n      weight: 3\n    },\n    // Western Gotland dispersed\n    {\n      minLat: 57.0,\n      maxLat: 58.5,\n      minLng: 20.0,\n      maxLng: 22.0,\n      weight: 3\n    },\n    // Eastern Gotland dispersed\n    {\n      minLat: 57.0,\n      maxLat: 58.5,\n      minLng: 22.0,\n      maxLng: 24.0,\n      weight: 3\n    } // Gulf of Riga dispersed\n    ];\n\n    // Calculate total weight\n    const totalWeight = shippingLanes.reduce((sum, lane) => sum + lane.weight, 0);\n\n    // Pick a random lane with weighting\n    let randomPoint = Math.random() * totalWeight;\n    let selectedLane = shippingLanes[0];\n    let cumulativeWeight = 0;\n    for (const lane of shippingLanes) {\n      cumulativeWeight += lane.weight;\n      if (randomPoint <= cumulativeWeight) {\n        selectedLane = lane;\n        break;\n      }\n    }\n\n    // Generate random point\n    const lng = selectedLane.minLng + Math.random() * (selectedLane.maxLng - selectedLane.minLng);\n    const lat = selectedLane.minLat + Math.random() * (selectedLane.maxLat - selectedLane.minLat);\n\n    // Check if the generated point is in an area to avoid\n    for (const area of avoidAreas) {\n      if (lat >= area.minLat && lat <= area.maxLat && lng >= area.minLng && lng <= area.maxLng) {\n        // If in an avoid area, recursively try again (with a maximum call stack check)\n        // This ensures we don't get stuck in an infinite loop\n        if (randomCoordinate.callCount === undefined) {\n          randomCoordinate.callCount = 0;\n        }\n        if (randomCoordinate.callCount < 10) {\n          randomCoordinate.callCount++;\n          const result = randomCoordinate();\n          randomCoordinate.callCount--;\n          return result;\n        } else {\n          // If we've tried too many times, just use a safe zone in the central Baltic\n          randomCoordinate.callCount = 0;\n          return [18.5 + Math.random() * 2, 56.5 + Math.random() * 2]; // Safe zone in central Baltic\n        }\n      }\n    }\n\n    // Reset call count\n    if (randomCoordinate.callCount !== undefined) {\n      randomCoordinate.callCount = 0;\n    }\n\n    // Return the coordinates\n    return [lng, lat];\n  };\n\n  // Generate 300 simulated vessels with realistic properties (reduced from 1000)\n  const generateVessels = useCallback(() => {\n    const vesselTypes = ['commercial', 'military', 'fishing', 'passenger', 'tanker'];\n    const flags = ['Finland', 'Sweden', 'Estonia', 'Latvia', 'Lithuania', 'Poland', 'Germany', 'Denmark', 'Russia'];\n    const russianOperators = ['Sovcomflot', 'Gazprom Fleet', 'Rosmorport', 'Russian Navy', 'Rosneft'];\n    const commercialOperators = ['Maersk', 'MSC', 'CMA CGM', 'Hapag-Lloyd', 'ONE', 'Evergreen', 'COSCO', 'Yang Ming', 'HMM', 'Grimaldi', 'DFDS', 'Stena Line', 'Tallink', 'Viking Line'];\n\n    // Generate vessels with better dispersal throughout the Baltic Sea\n    const generatedVessels = [];\n    const occupiedPositions = []; // Track positions to ensure better dispersal\n    const MIN_DISTANCE = 0.2; // Minimum distance between vessels in degrees (approx 10-20km)\n\n    // Start with fewer vessels and then disperse them more effectively\n    const maxAttempts = 600; // Increase attempts to find valid positions\n    let placedVesselCount = 0;\n\n    // Try to place vessels with appropriate spacing\n    for (let i = 1; placedVesselCount < 300 && i <= maxAttempts; i++) {\n      const type = vesselTypes[Math.floor(Math.random() * vesselTypes.length)];\n      const flag = flags[Math.floor(Math.random() * flags.length)];\n      const isRussian = flag === 'Russia' || Math.random() < 0.05; // 5% chance of non-Russian flag but Russian operated\n\n      // Get a potential position for the vessel\n      const position = randomCoordinate();\n\n      // Skip positions that are not in Baltic Sea water\n      if (!isInBalticSeaWaters(position[1], position[0])) {\n        continue;\n      }\n\n      // Check if this position is too close to existing vessels\n      let isTooClose = false;\n      for (const existingPos of occupiedPositions) {\n        const distance = Math.sqrt(Math.pow(position[0] - existingPos[0], 2) + Math.pow(position[1] - existingPos[1], 2));\n        if (distance < MIN_DISTANCE) {\n          isTooClose = true;\n          break;\n        }\n      }\n\n      // If the position is too close to other vessels, skip this attempt\n      if (isTooClose) {\n        continue;\n      }\n\n      // If we got here, the position is good, so add it to occupied positions\n      occupiedPositions.push(position);\n      placedVesselCount++;\n\n      // Calculate a more realistic heading based on position\n      // Ships in the Baltic generally move east-west in southern parts, and north-south in gulfs\n      let heading;\n      const vesselLat = position[1];\n      const vesselLng = position[0];\n\n      // Baltic shipping lane direction tendencies\n      if (vesselLng < 14.0) {\n        // Danish straits and western Baltic - generally east/west traffic\n        heading = Math.random() < 0.7 ? 70 + Math.random() * 40 : 250 + Math.random() * 40;\n      } else if (vesselLng > 23.0 && vesselLat > 59.0) {\n        // Gulf of Finland - generally east/west traffic\n        heading = Math.random() < 0.5 ? 80 + Math.random() * 30 : 260 + Math.random() * 30;\n      } else if (vesselLng > 19.0 && vesselLat > 60.0) {\n        // Gulf of Bothnia - generally north/south traffic\n        heading = Math.random() < 0.5 ? 0 + Math.random() * 30 : 180 + Math.random() * 30;\n      } else if (vesselLng > 22.0 && vesselLat < 58.0 && vesselLat > 56.5) {\n        // Gulf of Riga - generally north/south traffic\n        heading = Math.random() < 0.5 ? 0 + Math.random() * 40 : 180 + Math.random() * 40;\n      } else if (vesselLat < 56.0 && vesselLng > 18.0) {\n        // Southern Baltic to Polish/Lithuanian ports\n        heading = Math.random() < 0.6 ? 140 + Math.random() * 40 : 320 + Math.random() * 40;\n      } else {\n        // Central Baltic - mixed traffic patterns\n        heading = Math.floor(Math.random() * 360);\n      }\n\n      // Realistic speed based on vessel type and weather (assumed normal conditions)\n      let speed;\n      if (type === 'commercial' || type === 'tanker') {\n        speed = 10 + Math.floor(Math.random() * 8); // 10-18 knots\n      } else if (type === 'passenger') {\n        speed = 15 + Math.floor(Math.random() * 10); // 15-25 knots\n      } else if (type === 'military') {\n        speed = 5 + Math.floor(Math.random() * 25); // 5-30 knots (more variable)\n      } else if (type === 'fishing') {\n        // Fishing vessels move slower or may be stationary when fishing\n        speed = Math.random() < 0.3 ? 0 : 5 + Math.floor(Math.random() * 7); // 0 or 5-12 knots\n      } else {\n        speed = Math.floor(Math.random() * 15) + 5; // 5-20 knots default\n      }\n\n      // Determine vessel size\n      const length = type === 'tanker' || type === 'commercial' ? 100 + Math.floor(Math.random() * 300) : type === 'military' ? 50 + Math.floor(Math.random() * 200) : 20 + Math.floor(Math.random() * 50);\n\n      // Calculate gross tonnage (GT) based on vessel length and type\n      // Using simplified formula based on vessel dimensions\n      let grossTonnage;\n      if (type === 'commercial' || type === 'tanker') {\n        // Commercial and tanker vessels have higher GT/length ratios\n        grossTonnage = Math.round(length * length * 0.18); // Approximation\n      } else if (type === 'military') {\n        // Military vessels are typically more dense but smaller\n        grossTonnage = Math.round(length * length * 0.16);\n      } else if (type === 'passenger') {\n        // Passenger vessels have high volume and less dense cargo\n        grossTonnage = Math.round(length * length * 0.2);\n      } else {\n        // Fishing and other vessels\n        grossTonnage = Math.round(length * length * 0.12);\n      }\n\n      // Determine operator\n      let operator;\n      if (isRussian) {\n        operator = russianOperators[Math.floor(Math.random() * russianOperators.length)];\n      } else {\n        operator = commercialOperators[Math.floor(Math.random() * commercialOperators.length)];\n      }\n\n      // Generate a realistic vessel name\n      const prefixes = isRussian ? ['Admiral', 'Kapitan', 'Vostok', 'Sibir', 'Moskva', 'Sankt-Peterburg', 'Akademik'] : ['Northern', 'Baltic', 'Sea', 'Atlantic', 'Pacific', 'Star', 'Pioneer'];\n      const suffixes = isRussian ? ['Kuznetsov', 'Nakhimov', 'Gorshkov', 'Lazarev', 'Kasatonov', 'Ustinov'] : ['Adventurer', 'Explorer', 'Navigator', 'Voyager', 'Mariner', 'Trader', 'Express'];\n      const shipNumbers = ['I', 'II', 'III', 'IV', 'V', '1', '2', '3', '4', '5'];\n      let name;\n      if (Math.random() < 0.3) {\n        // 30% chance of having a prefix-suffix name\n        name = `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;\n      } else if (Math.random() < 0.5) {\n        // 20% chance of having a name with a number\n        name = `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${shipNumbers[Math.floor(Math.random() * shipNumbers.length)]}`;\n      } else {\n        // 50% chance of having a simple prefix or suffix name\n        name = Math.random() < 0.5 ? prefixes[Math.floor(Math.random() * prefixes.length)] : suffixes[Math.floor(Math.random() * suffixes.length)];\n      }\n      if (type === 'military' && isRussian) {\n        name = `RFS ${name}`; // Russian Federation Ship\n      }\n\n      // Calculate a detection probability\n      const detectionProbability = {\n        radar: Math.random(),\n        // 0-1, higher means more visible on radar\n        sonar: Math.random(),\n        // 0-1, higher means more detectable by sonar\n        fused: (Math.random() + Math.random()) / 2 // average of two values for a more normal distribution\n      };\n\n      // Generate a vessel object with all properties\n      generatedVessels.push({\n        id: placedVesselCount,\n        name,\n        type,\n        flag,\n        isRussian,\n        position,\n        heading,\n        speed,\n        length,\n        operator,\n        detectionProbability,\n        grossTonnage\n      });\n    }\n\n    // More evenly disperse submarines too\n    // Generate Russian submarines with special characteristics\n    const submarineNames = ['Krasnodar', 'Novorossiysk', 'Rostov-on-Don', 'Stary Oskol', 'Velikiy Novgorod', 'Kolpino', 'Sankt Peterburg'];\n    const submarineClasses = ['Kilo-class', 'Kilo-class', 'Kilo-class', 'Kilo-class', 'Improved Kilo-class', 'Improved Kilo-class', 'Lada-class'];\n    const submarineDesignations = ['B-265', 'B-261', 'B-237', 'B-262', 'B-268', 'B-271', 'B-585'];\n\n    // Use more strategic submarine positions\n    const submarineAreas = [\n    // Gulf of Finland approach - monitoring traffic to St. Petersburg\n    [26.2, 59.7],\n    // Near NATO naval exercise areas in central Baltic\n    [19.3, 56.8],\n    // Monitoring approach to Stockholm archipelago\n    [18.9, 58.9],\n    // Deep water between Gotland and Latvia (strategic position)\n    [20.1, 57.3],\n    // Patrolling near Kaliningrad naval base\n    [19.6, 55.2],\n    // Monitoring naval traffic near Gdańsk\n    [18.8, 54.8],\n    // Danish straits approaches - key strategic chokepoint\n    [12.8, 55.4]];\n\n    // Add some randomness to submarine positions to avoid perfect predictability\n    const randomizedSubmarineAreas = submarineAreas.map(pos => [pos[0] + (Math.random() - 0.5) * 0.5,\n    // Add up to ±0.25 degrees longitude\n    pos[1] + (Math.random() - 0.5) * 0.3 // Add up to ±0.15 degrees latitude\n    ]);\n\n    // Add submarines to generated vessels\n    for (let i = 0; i < 7; i++) {\n      const position = randomizedSubmarineAreas[i];\n\n      // Skip submarine positions that aren't in Baltic Sea water\n      if (!isInBalticSeaWaters(position[1], position[0])) {\n        // Try to find a better position by adjusting slightly\n        for (let attempt = 0; attempt < 5; attempt++) {\n          // Try adjusting position slightly to find water\n          const adjustedPosition = [position[0] + (Math.random() - 0.5) * 0.5, position[1] + (Math.random() - 0.5) * 0.5];\n          if (isInBalticSeaWaters(adjustedPosition[1], adjustedPosition[0])) {\n            // Found a valid position\n            position[0] = adjustedPosition[0];\n            position[1] = adjustedPosition[1];\n            break;\n          }\n        }\n\n        // If still not in water after adjustments, skip this submarine\n        if (!isInBalticSeaWaters(position[1], position[0])) {\n          continue;\n        }\n      }\n      const heading = Math.floor(Math.random() * 360);\n      const speed = 5 + Math.floor(Math.random() * 10); // Submarines move slower on average\n      const depth = 20 + Math.floor(Math.random() * 180); // Depth in meters\n\n      // Submarine detection characteristics\n      // Low radar detection when submerged, high sonar signature\n      const isSubmerged = Math.random() > 0.3; // 70% chance of being submerged\n\n      const detectionProbability = {\n        radar: isSubmerged ? 0.05 + Math.random() * 0.1 : 0.3 + Math.random() * 0.2,\n        // Low radar when submerged\n        sonar: 0.6 + Math.random() * 0.4,\n        // High sonar signature\n        fused: isSubmerged ? (0.05 + Math.random() * 0.1 + 0.6 + Math.random() * 0.4) / 2 :\n        // Average when submerged\n        (0.3 + Math.random() * 0.2 + 0.6 + Math.random() * 0.4) / 2 // Average when surfaced\n      };\n      generatedVessels.push({\n        id: 1001 + i,\n        // IDs starting from 1001 for submarines\n        name: `RFS ${submarineNames[i]}`,\n        type: 'submarine',\n        class: submarineClasses[i],\n        designation: submarineDesignations[i],\n        flag: 'Russia',\n        isRussian: true,\n        position,\n        heading,\n        speed,\n        depth,\n        length: 70 + Math.floor(Math.random() * 20),\n        // Kilo-class submarines are around 70-74m\n        isSubmerged,\n        operator: 'Russian Navy',\n        detectionProbability\n      });\n    }\n    return generatedVessels;\n  }, []);\n\n  // Generate vessel data when component mounts\n  useEffect(() => {\n    const simulatedVessels = generateVessels();\n    setVessels(simulatedVessels);\n  }, [generateVessels]);\n\n  // Update vessel positions based on speed and heading\n  const updateVesselPositions = useCallback(() => {\n    if (!simulationEnabled) return;\n    const currentTime = Date.now();\n    const deltaTime = (currentTime - lastUpdateTimeRef.current) / 1000; // Convert ms to seconds\n    lastUpdateTimeRef.current = currentTime;\n\n    // Apply speed multiplier to deltaTime\n    const adjustedDeltaTime = deltaTime * simulationSpeed;\n\n    // Skip if delta time is too large (e.g., browser tab was inactive)\n    if (adjustedDeltaTime > 5) return;\n    setVessels(prevVessels => {\n      return prevVessels.map(vessel => {\n        // Skip stationary vessels\n        if (vessel.speed === 0) return vessel;\n\n        // Convert knots to degrees per second\n        // 1 knot ≈ 0.0003 degrees of longitude at the equator per second\n        // Adjust for latitude (narrower longitude degrees at higher latitudes)\n        const latitudeAdjustment = Math.cos(vessel.position[1] * Math.PI / 180);\n        const longitudeChange = vessel.speed * 0.0003 * adjustedDeltaTime / latitudeAdjustment;\n        const latitudeChange = vessel.speed * 0.0003 * adjustedDeltaTime;\n\n        // Calculate new position based on heading\n        const headingRad = vessel.heading * Math.PI / 180;\n        const newLng = vessel.position[0] + longitudeChange * Math.sin(headingRad);\n        const newLat = vessel.position[1] + latitudeChange * Math.cos(headingRad);\n\n        // Enhanced boundary checking to keep vessels within the actual Baltic Sea water\n        if (!isInBalticSeaWaters(newLat, newLng)) {\n          // If would move onto land or out of bounds, adjust heading to turn back toward deeper water\n          // Use a more detailed approach to find the right direction\n\n          // Try finding a better direction by checking multiple angles\n          let bestHeading = vessel.heading;\n          let foundBetterDirection = false;\n\n          // Check 8 directions around to find waters\n          for (let angleOffset = 0; angleOffset < 360; angleOffset += 45) {\n            const testHeading = (vessel.heading + angleOffset) % 360;\n            const testRad = testHeading * Math.PI / 180;\n\n            // Check a position further out in this direction\n            const testLng = vessel.position[0] + longitudeChange * 5 * Math.sin(testRad);\n            const testLat = vessel.position[1] + latitudeChange * 5 * Math.cos(testRad);\n            if (isInBalticSeaWaters(testLat, testLng)) {\n              bestHeading = testHeading;\n              foundBetterDirection = true;\n              break;\n            }\n          }\n\n          // If no good direction found, head toward the Baltic center\n          if (!foundBetterDirection) {\n            const centerLat = 58.5; // More centered in the main Baltic basin\n            const centerLng = 20; // Adjusted to be in deeper waters\n            const angleToCenter = Math.atan2(centerLng - vessel.position[0], centerLat - vessel.position[1]) * 180 / Math.PI;\n\n            // Turn gradually toward the center\n            const headingDiff = (angleToCenter - vessel.heading + 540) % 360 - 180;\n            bestHeading = (vessel.heading + Math.sign(headingDiff) * 45) % 360;\n            if (bestHeading < 0) bestHeading += 360;\n          }\n\n          // Slow down near boundaries\n          const reducedSpeed = Math.max(1, vessel.speed * 0.5);\n          return {\n            ...vessel,\n            heading: bestHeading,\n            speed: reducedSpeed // Temporarily reduce speed when changing course\n          };\n        }\n\n        // For military and submarine vessels, randomly change heading occasionally\n        let newHeading = vessel.heading;\n        const originalSpeed = vessel.speed;\n        let newSpeed = originalSpeed;\n        if ((vessel.type === 'military' || vessel.type === 'submarine') && Math.random() < 0.01 * adjustedDeltaTime) {\n          // Change heading by up to +/- 30 degrees\n          newHeading = (vessel.heading + (Math.random() * 60 - 30)) % 360;\n          if (newHeading < 0) newHeading += 360;\n\n          // Military vessels might change speed during maneuvers\n          if (Math.random() < 0.3) {\n            const speedFactor = 0.7 + Math.random() * 0.6; // 70-130% of current speed\n            newSpeed = Math.max(1, Math.min(30, originalSpeed * speedFactor));\n          }\n        }\n        // Smaller random heading changes for other vessels to simulate realistic movement\n        else if (Math.random() < 0.005 * adjustedDeltaTime) {\n          // Change heading by up to +/- 10 degrees\n          newHeading = (vessel.heading + (Math.random() * 20 - 10)) % 360;\n          if (newHeading < 0) newHeading += 360;\n        }\n\n        // Final position check - ensure vessel doesn't go on land even after all other checks\n        const finalLng = newLng;\n        const finalLat = newLat;\n\n        // If vessel would end up on land, don't update position but keep the heading change\n        if (!isInBalticSeaWaters(finalLat, finalLng)) {\n          return {\n            ...vessel,\n            heading: newHeading,\n            speed: newSpeed\n          };\n        }\n\n        // Special check for Swedish coastline (which seems particularly problematic)\n        // These bounds roughly define the Swedish coastline area\n        const isNearSwedishCoast = finalLat >= 55.0 && finalLat <= 60.0 && finalLng >= 12.0 && finalLng <= 19.0 && (\n        // Distance to coast is small\n        finalLng >= 12.0 && finalLng <= 14.0 ||\n        // Western coast\n        finalLat >= 58.0 && finalLat <= 60.0 && finalLng >= 16.5 && finalLng <= 19.0 ||\n        // Stockholm area\n        finalLat >= 56.0 && finalLat <= 58.0 && finalLng >= 15.5 && finalLng <= 17.0) // Eastern coast\n        ;\n\n        // For vessels near Swedish coast, make extra check by testing multiple points\n        if (isNearSwedishCoast && Math.random() < 0.7) {\n          // 70% extra caution near Swedish coast\n          const currentPos = vessel.position;\n          const distance = Math.sqrt(Math.pow(finalLng - currentPos[0], 2) + Math.pow(finalLat - currentPos[1], 2));\n\n          // If making a significant move near Swedish coast, stay put instead of risking land\n          if (distance > 0.02) {\n            return {\n              ...vessel,\n              heading: newHeading,\n              speed: Math.max(1, newSpeed * 0.5) // Reduce speed near coast\n            };\n          }\n        }\n        return {\n          ...vessel,\n          position: [finalLng, finalLat],\n          heading: newHeading,\n          speed: newSpeed\n        };\n      });\n    });\n\n    // Request next animation frame\n    animationFrameRef.current = requestAnimationFrame(updateVesselPositions);\n  }, [simulationEnabled, simulationSpeed]);\n\n  // Function to check if a point is in Baltic Sea waters\n  // This is a more precise check than just the bounding box\n  const isInBalticSeaWaters = useCallback((lat, lng) => {\n    // First check overall bounds\n    if (lat < 54.0 || lat > 66.0 || lng < 9.0 || lng > 30.0) {\n      return false;\n    }\n\n    // Define areas that are land (to be avoided)\n    // Format: [south, north, west, east]\n    const landAreas = [\n    // Southern Sweden - expanded and more precise with additional coverage\n    [55.0, 59.5, 12.5, 16.0],\n    // Southern Sweden - additional western coast coverage\n    [56.0, 58.8, 11.5, 13.0],\n    // Stockholm archipelago area - more precise\n    [59.0, 60.0, 17.0, 19.2],\n    // Sweden central eastern coast - additional coverage\n    [58.0, 59.5, 16.0, 17.8],\n    // Northern Sweden - Gulf of Bothnia coastline\n    [60.0, 63.0, 17.0, 19.5],\n    // Northern Sweden - upper Gulf of Bothnia\n    [63.0, 65.5, 17.0, 22.0],\n    // Northern Sweden - northwestern area\n    [64.0, 66.0, 15.0, 17.0],\n    // Finland - expanded\n    [59.7, 65.5, 21.0, 30.0],\n    // Estonia - expanded\n    [57.5, 59.7, 22.8, 28.5],\n    // Latvia/Lithuania coast - expanded\n    [55.5, 57.5, 20.8, 28.0],\n    // Poland inland - expanded\n    [54.0, 55.5, 14.8, 19.8],\n    // Germany/Denmark inland - expanded\n    [54.0, 56.5, 9.0, 12.0],\n    // Gotland - more precise\n    [56.8, 58.0, 18.0, 19.2],\n    // Åland Islands - expanded\n    [59.7, 60.5, 19.3, 21.3],\n    // Bornholm - more precise\n    [54.9, 55.3, 14.7, 15.2],\n    // Öland\n    [56.1, 57.5, 16.3, 17.1],\n    // Rügen\n    [54.2, 54.7, 13.0, 13.6],\n    // Saaremaa\n    [57.8, 58.7, 21.7, 23.0],\n    // Hiiumaa\n    [58.7, 59.1, 22.0, 23.0],\n    // Inland lakes in Finland\n    [61.0, 63.0, 25.0, 30.0],\n    // Kaliningrad and surrounding area\n    [54.3, 55.3, 19.6, 22.5]];\n\n    // Define key shipping channels and deep waters (preferred areas)\n    // Format: [south, north, west, east, weight]\n    const shippingChannels = [\n    // Main Baltic basin\n    [55.5, 59.0, 16.5, 22.0, 10],\n    // Gulf of Finland shipping lane\n    [59.3, 60.2, 22.5, 28.0, 8],\n    // Approach to Stockholm\n    [58.7, 59.5, 17.5, 19.5, 6],\n    // Approach to Riga\n    [56.8, 58.0, 22.5, 24.5, 6],\n    // Approach to Helsinki/Tallinn\n    [59.2, 59.9, 24.0, 25.5, 8],\n    // Western Baltic shipping lane\n    [54.5, 56.0, 12.0, 15.0, 8],\n    // Kattegat\n    [56.0, 57.5, 10.5, 12.0, 6],\n    // Gulf of Bothnia\n    [60.5, 63.5, 18.5, 21.5, 5],\n    // Central Baltic - expanded to cover more water\n    [56.0, 59.0, 17.5, 21.0, 10],\n    // Southern Baltic - expanded\n    [54.5, 56.5, 15.0, 19.0, 8]];\n\n    // Check if point is in a land area - more strict checking\n    for (const [south, north, west, east] of landAreas) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // Further check for complex coastlines\n        // This is a very simplified approach - we add some randomness \n        // to prevent vessels from getting stuck at sharp boundary transitions\n\n        // If near the edge of a land area, there's a small chance to still consider it water\n        // This helps vessels navigate around complex coastlines without getting stuck\n        const distanceFromEdge = Math.min(Math.abs(lat - south), Math.abs(lat - north), Math.abs(lng - west), Math.abs(lng - east));\n\n        // Very close to edge - might be a complex coastline\n        if (distanceFromEdge < 0.1) {\n          // 15% chance to consider it water if very close to edge (reduced from 20%)\n          // This randomness helps prevent getting stuck at boundaries\n          return Math.random() < 0.15;\n        }\n        return false; // It's in a land area\n      }\n    }\n\n    // Check if in a preferred shipping channel\n    for (const [south, north, west, east] of shippingChannels) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        return true; // In a shipping channel - definitely good\n      }\n    }\n\n    // For areas not explicitly defined, use the following general rules\n\n    // Avoid shallow coastal waters (simplified approach)\n    // These are general buffer zones around landmasses\n    const coastalBuffers = [\n    // Swedish coast buffer - expanded\n    [55.0, 59.5, 14.8, 16.5],\n    // Swedish west coast buffer\n    [56.0, 58.8, 11.0, 12.2],\n    // Swedish eastern coastline\n    [58.0, 59.5, 16.0, 17.0],\n    // Northern Sweden - Gulf of Bothnia western coast\n    [60.0, 63.0, 19.0, 20.0],\n    // Northern Sweden - upper coast\n    [63.0, 65.5, 19.5, 22.5],\n    // Finnish coast buffer\n    [59.7, 65.5, 20.0, 21.5],\n    // Estonian coast buffer\n    [57.5, 59.7, 22.0, 23.0],\n    // Latvian/Lithuanian coast buffer\n    [55.5, 57.5, 19.5, 21.5],\n    // Polish coast buffer\n    [54.0, 55.5, 14.0, 15.5],\n    // German/Danish coast buffer\n    [54.0, 56.0, 12.0, 13.0]];\n\n    // Check coastal buffers with higher probability of rejection\n    for (const [south, north, west, east] of coastalBuffers) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 80% chance to consider coastal buffers as land (increased from 70%)\n        return Math.random() > 0.8;\n      }\n    }\n\n    // Special check for Swedish coastal waters - these are problematic\n    const swedishProblemAreas = [\n    // Stockholm archipelago approaches\n    [58.8, 59.5, 17.5, 19.0],\n    // Swedish eastern coastline near Öland\n    [56.5, 57.5, 16.0, 16.8],\n    // Swedish western approaches\n    [57.0, 58.5, 11.2, 12.5],\n    // Northern Sweden Gulf of Bothnia western coast\n    [60.0, 63.0, 18.5, 20.0],\n    // Northern Sweden - northeastern area\n    [63.0, 65.0, 19.0, 22.0]];\n\n    // Higher rejection rate specifically for Swedish coastal waters\n    for (const [south, north, west, east] of swedishProblemAreas) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 90% chance to reject - very strict for Swedish waters\n        return Math.random() > 0.9;\n      }\n    }\n\n    // Additional check for enclosed bays and lakes\n    // Define problematic enclosed areas (small bays, inlets, etc.)\n    const problematicAreas = [\n    // Finnish inland lake areas \n    [60.7, 62.5, 23.0, 29.0],\n    // Swedish lake areas\n    [58.5, 59.5, 14.0, 16.0],\n    // Various small bays and inlets\n    [57.2, 57.6, 16.8, 17.2],\n    // Near Öland\n    [60.0, 60.2, 24.8, 25.2],\n    // Helsinki area\n    [58.8, 59.0, 17.5, 18.0],\n    // Stockholm archipelago\n    [58.1, 58.5, 11.5, 12.0] // Skagerrak entrance\n    ];\n\n    // Higher chance to reject problematic areas\n    for (const [south, north, west, east] of problematicAreas) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 60% chance to reject\n        return Math.random() > 0.6;\n      }\n    }\n\n    // Explicitly define major lakes to avoid them completely\n    const majorLakes = [\n    // Swedish lakes\n    [58.0, 59.3, 12.3, 14.0],\n    // Vänern\n    [57.7, 58.7, 14.0, 14.8],\n    // Vättern\n    [59.1, 59.7, 15.8, 18.0],\n    // Mälaren\n    [56.9, 57.5, 13.4, 14.8],\n    // Southern Swedish lakes\n    [56.8, 57.2, 14.4, 15.2],\n    // Åsnen and nearby lakes\n\n    // Finnish lakes\n    [61.0, 62.3, 24.5, 26.4],\n    // Päijänne and nearby\n    [61.3, 63.1, 26.5, 29.0],\n    // Saimaa system\n    [62.0, 63.7, 23.0, 24.5],\n    // Western Finnish lakes\n    [61.5, 62.2, 28.5, 29.8],\n    // Eastern Finnish lakes\n    [60.3, 60.8, 23.5, 25.0],\n    // Southern Finnish lakes\n\n    // Russian lakes\n    [60.0, 61.8, 29.2, 32.0],\n    // Ladoga\n    [60.0, 60.8, 27.4, 29.0],\n    // Eastern Gulf of Finland lakes\n    [57.8, 59.0, 26.5, 28.5],\n    // Peipus\n\n    // Other inland waters\n    [54.1, 54.7, 17.8, 18.7],\n    // Polish lakes\n    [53.5, 54.3, 12.0, 14.0],\n    // German lakes\n    [53.8, 55.0, 10.2, 11.0],\n    // Danish inland waters\n    [55.5, 56.5, 9.5, 10.2] // Limfjord area\n    ];\n\n    // Strict rejection of major lakes - almost never allow vessels here\n    for (const [south, north, west, east] of majorLakes) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 99.5% chance to consider these as land - essentially never allow vessels in lakes\n        return Math.random() > 0.995;\n      }\n    }\n\n    // Known safe water zones - replaced with enhanced version\n    const safeWaterZones = [\n    // Central Baltic open water\n    [56.5, 58.5, 18.0, 21.0],\n    // Eastern Baltic open water\n    [57.0, 59.0, 20.0, 22.0],\n    // Western Baltic open water\n    [55.0, 56.5, 13.0, 15.0],\n    // Southern Baltic deep water\n    [54.5, 55.5, 16.0, 18.5],\n    // Gulf of Finland central channel\n    [59.4, 60.0, 23.0, 27.0],\n    // Gulf of Bothnia southern part - central channel\n    [60.5, 62.5, 20.0, 21.0],\n    // Gulf of Bothnia central part - central channel\n    [62.5, 64.0, 20.2, 21.2],\n    // Gulf of Bothnia northern part - central channel\n    [64.0, 65.0, 21.5, 22.5]];\n\n    // If in a known safe water zone, it's definitely water\n    for (const [south, north, west, east] of safeWaterZones) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        return true;\n      }\n    }\n\n    // Special check for northern Gulf of Bothnia - narrower channel\n    if (lat >= 63.0 && lat <= 65.5 && lng >= 20.0 && lng <= 22.0) {\n      // In the narrower northern part of Gulf of Bothnia, be more restrictive\n      // Only consider central waters as safe (within 0.3° from center line)\n      const centerLng = 21.0;\n      const distanceFromCenter = Math.abs(lng - centerLng);\n      if (distanceFromCenter < 0.3) {\n        return true; // Central channel\n      } else if (distanceFromCenter < 0.5) {\n        // In the transition zone, random chance to allow\n        return Math.random() > 0.7;\n      } else {\n        // Too close to shore\n        return Math.random() > 0.95; // Very small chance to consider as water\n      }\n    }\n\n    // If we got here, it's probably in open water\n    return true;\n  }, []);\n\n  // Start/stop vessel position updates when simulation state changes\n  useEffect(() => {\n    if (simulationEnabled) {\n      lastUpdateTimeRef.current = Date.now();\n      animationFrameRef.current = requestAnimationFrame(updateVesselPositions);\n    } else if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n\n    // Cleanup when component unmounts\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [simulationEnabled, updateVesselPositions]);\n\n  // Function to check if an item is in the current map bounds\n  const isInMapBounds = useCallback((lat, lng) => {\n    if (!mapBounds) return true; // If no bounds yet, show everything\n\n    // Add buffer to avoid popping at edges\n    const buffer = 0.5; // Buffer in degrees\n\n    return lat >= mapBounds.south - buffer && lat <= mapBounds.north + buffer && lng >= mapBounds.west - buffer && lng <= mapBounds.east + buffer;\n  }, [mapBounds]);\n\n  // Simple implementation of renderVessels\n  const renderVessels = useCallback(() => {\n    console.log(`Rendering ${vessels.length} vessels`);\n    if (vessels.length === 0) {\n      console.log(\"No vessels to render\");\n      return null;\n    }\n    return vessels.map(vessel => {\n      if (!vessel.position || vessel.position.length < 2) {\n        console.log(\"Invalid vessel position:\", vessel);\n        return null;\n      }\n      const position = {\n        lat: vessel.position[1],\n        lng: vessel.position[0]\n      };\n\n      // Simple marker for vessels\n      return /*#__PURE__*/_jsxDEV(MemoizedMarker, {\n        position: position,\n        icon: {\n          path: \"M -1,1 L 1,1 L 1,-1 L -1,-1 Z\",\n          // Simple square\n          fillColor: vessel.isRussian ? 'rgb(231, 76, 60)' : 'rgb(52, 152, 219)',\n          fillOpacity: 0.8,\n          strokeColor: '#FFFFFF',\n          strokeWeight: 1,\n          scale: 3,\n          rotation: vessel.heading || 0\n        },\n        onClick: () => setSelectedVessel(vessel)\n      }, vessel.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1142,\n        columnNumber: 9\n      }, this);\n    });\n  }, [vessels, setSelectedVessel]);\n\n  // Simple implementations of other render functions\n  const renderWindFarms = useCallback(() => {\n    console.log(\"Rendering wind farms\");\n    return null; // Simplified, no wind farms\n  }, []);\n  const renderRadarCoverage = useCallback(() => {\n    console.log(\"Rendering radar coverage\");\n    return null; // Simplified\n  }, []);\n  const renderVesselRadarCoverage = useCallback(() => {\n    console.log(\"Rendering vessel radar coverage\");\n    return null; // Simplified\n  }, []);\n\n  // Memoize UI elements that don't need frequent updates\n  const controlPanels = useMemo(() => /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.controlPanel,\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        style: styles.heading,\n        children: \"Display Controls\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1180,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          flexDirection: 'column',\n          gap: '8px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          style: showVesselRadar ? {\n            ...styles.buttonActive,\n            backgroundColor: '#2563EB'\n          } : styles.button,\n          onClick: () => setShowVesselRadar(!showVesselRadar),\n          children: [/*#__PURE__*/_jsxDEV(Radar, {\n            size: 16,\n            style: {\n              marginRight: '8px'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1186,\n            columnNumber: 13\n          }, this), showVesselRadar ? 'Hide Vessel Radar' : 'Show Vessel Radar']\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1182,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: simulationEnabled ? {\n            ...styles.buttonActive,\n            backgroundColor: '#16A34A'\n          } : styles.button,\n          onClick: () => setSimulationEnabled(!simulationEnabled),\n          children: [/*#__PURE__*/_jsxDEV(Ship, {\n            size: 16,\n            style: {\n              marginRight: '8px'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1194,\n            columnNumber: 13\n          }, this), simulationEnabled ? 'Stop Movement' : 'Simulate Movement']\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1190,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: seaMeshSimulationEnabled ? {\n            ...styles.buttonActive,\n            backgroundColor: '#D97706'\n          } : {\n            ...styles.button,\n            backgroundColor: '#B45309'\n          },\n          onClick: () => setSeaMeshSimulationEnabled(!seaMeshSimulationEnabled),\n          children: [/*#__PURE__*/_jsxDEV(Radar, {\n            size: 16,\n            style: {\n              marginRight: '8px'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1205,\n            columnNumber: 13\n          }, this), seaMeshSimulationEnabled ? 'Stop SeaMesh' : 'Simulate SeaMesh']\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1198,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1181,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1179,\n      columnNumber: 7\n    }, this)\n  }, void 0, false), [showVesselRadar, simulationEnabled, seaMeshSimulationEnabled]);\n\n  // Simple function to render sea mesh simulation\n  const renderSeaMeshSimulation = useCallback(() => {\n    console.log(\"Rendering SeaMesh simulation\");\n\n    // Mock data for demonstration\n    const seaMeshPoints = [{\n      lat: 59.5,\n      lng: 20.5\n    }, {\n      lat: 60.0,\n      lng: 21.0\n    }, {\n      lat: 59.8,\n      lng: 21.5\n    }, {\n      lat: 59.3,\n      lng: 21.2\n    }];\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: seaMeshPoints.map((point, index) => /*#__PURE__*/_jsxDEV(Circle, {\n        center: point,\n        radius: 5000,\n        options: {\n          fillColor: '#3B82F6',\n          fillOpacity: 0.3,\n          strokeColor: '#2563EB',\n          strokeOpacity: 0.8,\n          strokeWeight: 1\n        }\n      }, `seamesh-${index}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1228,\n        columnNumber: 11\n      }, this))\n    }, void 0, false);\n  }, []);\n\n  // Update UI to include display mode toggle\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'flex',\n        flex: 1\n      },\n      children: [showSidebar && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: styles.sidebar,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'space-between',\n            marginBottom: '16px'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n            style: {\n              fontSize: '20px',\n              fontWeight: 'bold',\n              color: '#3D85C6'\n            },\n            children: \"Baltic Sea Tracker\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1252,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => setShowSidebar(false),\n            style: {\n              background: 'none',\n              border: 'none',\n              color: '#888888',\n              cursor: 'pointer'\n            },\n            children: /*#__PURE__*/_jsxDEV(Menu, {\n              size: 20\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1254,\n              columnNumber: 17\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1253,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1251,\n          columnNumber: 13\n        }, this), controlPanels]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1250,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          flex: 1,\n          position: 'relative'\n        },\n        children: [!showSidebar && /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            position: 'absolute',\n            top: '16px',\n            left: '16px',\n            zIndex: 10,\n            backgroundColor: '#1F2937',\n            padding: '8px',\n            borderRadius: '4px',\n            border: 'none',\n            cursor: 'pointer'\n          },\n          onClick: () => setShowSidebar(true),\n          children: /*#__PURE__*/_jsxDEV(Menu, {\n            size: 20,\n            color: \"#D1D5DB\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1278,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1264,\n          columnNumber: 13\n        }, this), loadError && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"w-full h-full flex flex-col items-center justify-center bg-gray-900 text-white p-4\",\n          children: /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"text-xl mb-4\",\n            children: [\"Error loading Google Maps: \", loadError.message]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1285,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1284,\n          columnNumber: 13\n        }, this), isLoaded ? /*#__PURE__*/_jsxDEV(GoogleMap, {\n          id: \"map\",\n          mapContainerStyle: styles.map,\n          center: mapCenter,\n          zoom: mapZoom,\n          options: mapOptions,\n          onLoad: onMapLoad,\n          children: [vessels.length > 0 && vessels.map(vessel => {\n            if (!vessel.position || vessel.position.length < 2) return null;\n            const position = {\n              lat: vessel.position[1],\n              lng: vessel.position[0]\n            };\n            return /*#__PURE__*/_jsxDEV(MemoizedMarker, {\n              position: position,\n              icon: {\n                path: \"M -1,1 L 1,1 L 1,-1 L -1,-1 Z\",\n                // Simple square\n                fillColor: vessel.isRussian ? 'rgb(231, 76, 60)' : 'rgb(52, 152, 219)',\n                fillOpacity: 0.8,\n                strokeColor: '#FFFFFF',\n                strokeWeight: 1,\n                scale: 3,\n                rotation: vessel.heading || 0\n              },\n              onClick: () => setSelectedVessel(vessel)\n            }, vessel.id, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1305,\n              columnNumber: 19\n            }, this);\n          }), seaMeshSimulationEnabled && renderSeaMeshSimulation()]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1290,\n          columnNumber: 13\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center',\n            backgroundColor: '#1F2937',\n            color: 'white'\n          },\n          children: /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              fontSize: '20px'\n            },\n            children: \"Loading map...\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1335,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1326,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1262,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1248,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: styles.footer,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center'\n        },\n        children: [/*#__PURE__*/_jsxDEV(Info, {\n          size: 16,\n          style: {\n            marginRight: '4px',\n            color: '#3B82F6'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1343,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            color: '#D1D5DB'\n          },\n          children: [\"Baltic Sea Tracker - \", vessels.length, \" vessels | Zoom: \", currentZoom]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1344,\n          columnNumber: 11\n        }, this), seaMeshSimulationEnabled && /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            margin: '0 4px',\n            color: '#F59E0B'\n          },\n          children: \"| SeaMesh Simulation Active\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1345,\n          columnNumber: 40\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1342,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1341,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1247,\n    columnNumber: 5\n  }, this);\n};\n_s(BalticSeaTracker, \"blgz35BFPb2TfA/b02vlllPjNRk=\", false, function () {\n  return [useJsApiLoader];\n});\n_c5 = BalticSeaTracker;\nexport default BalticSeaTracker;\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"MemoizedMarker\");\n$RefreshReg$(_c2, \"MemoizedCircle\");\n$RefreshReg$(_c3, \"MemoizedPolygon\");\n$RefreshReg$(_c4, \"MemoizedPolyline\");\n$RefreshReg$(_c5, \"BalticSeaTracker\");","map":{"version":3,"names":["React","useEffect","useState","useRef","useCallback","useMemo","memo","Info","Ship","Menu","ZoomIn","ZoomOut","Radar","Waves","Layers","Wind","GoogleMap","useJsApiLoader","Marker","Circle","Polyline","Polygon","jsxDEV","_jsxDEV","Fragment","_Fragment","styles","container","display","flexDirection","height","backgroundColor","map","width","sidebar","color","padding","overflowY","controlPanel","marginBottom","borderRadius","buttonActive","border","cursor","alignItems","button","heading","fontSize","fontWeight","footer","textAlign","MemoizedMarker","_c","MemoizedCircle","_c2","MemoizedPolygon","_c3","MemoizedPolyline","_c4","mapContainerStyle","defaultCenter","lat","lng","BalticSeaTracker","_s","isLoaded","loadError","id","googleMapsApiKey","libraries","console","log","vessels","setVessels","selectedVessel","setSelectedVessel","filter","setFilter","showSidebar","setShowSidebar","displayMode","setDisplayMode","showWindFarms","setShowWindFarms","showRadarCoverage","setShowRadarCoverage","showVesselRadar","setShowVesselRadar","showLargeVesselRadar","setShowLargeVesselRadar","mapBounds","setMapBounds","currentZoom","setCurrentZoom","mapKey","setMapKey","Date","now","simulationEnabled","setSimulationEnabled","simulationSpeed","setSimulationSpeed","seaMeshSimulationEnabled","setSeaMeshSimulationEnabled","simulationStep","setSimulationStep","warships","setWarships","detectionRings","setDetectionRings","animationFrameRef","lastUpdateTimeRef","seaMeshAnimationRef","zoomRef","mapRef","mapCenter","mapZoom","currentMapCenter","setCurrentMapCenter","mapStyle","getMapStyle","mapOptions","disableDefaultUI","zoomControl","draggable","restrictions","latLngBounds","north","south","east","west","mapsLoadedRef","error","current","length","mockVessels","Array","fill","_","index","name","type","isRussian","position","Math","random","speed","flag","grossTonnage","floor","mode","elementType","stylers","featureType","visibility","randomCoordinate","avoidAreas","minLat","maxLat","minLng","maxLng","shippingLanes","weight","totalWeight","reduce","sum","lane","randomPoint","selectedLane","cumulativeWeight","area","callCount","undefined","result","generateVessels","vesselTypes","flags","russianOperators","commercialOperators","generatedVessels","occupiedPositions","MIN_DISTANCE","maxAttempts","placedVesselCount","i","isInBalticSeaWaters","isTooClose","existingPos","distance","sqrt","pow","push","vesselLat","vesselLng","round","operator","prefixes","suffixes","shipNumbers","detectionProbability","radar","sonar","fused","submarineNames","submarineClasses","submarineDesignations","submarineAreas","randomizedSubmarineAreas","pos","attempt","adjustedPosition","depth","isSubmerged","class","designation","simulatedVessels","updateVesselPositions","currentTime","deltaTime","adjustedDeltaTime","prevVessels","vessel","latitudeAdjustment","cos","PI","longitudeChange","latitudeChange","headingRad","newLng","sin","newLat","bestHeading","foundBetterDirection","angleOffset","testHeading","testRad","testLng","testLat","centerLat","centerLng","angleToCenter","atan2","headingDiff","sign","reducedSpeed","max","newHeading","originalSpeed","newSpeed","speedFactor","min","finalLng","finalLat","isNearSwedishCoast","currentPos","requestAnimationFrame","landAreas","shippingChannels","distanceFromEdge","abs","coastalBuffers","swedishProblemAreas","problematicAreas","majorLakes","safeWaterZones","distanceFromCenter","cancelAnimationFrame","isInMapBounds","buffer","renderVessels","icon","path","fillColor","fillOpacity","strokeColor","strokeWeight","scale","rotation","onClick","fileName","_jsxFileName","lineNumber","columnNumber","renderWindFarms","renderRadarCoverage","renderVesselRadarCoverage","controlPanels","children","style","gap","size","marginRight","renderSeaMeshSimulation","seaMeshPoints","point","center","radius","options","strokeOpacity","flex","justifyContent","background","top","left","zIndex","className","message","zoom","onLoad","onMapLoad","margin","_c5","$RefreshReg$"],"sources":["/Users/esbenvahr/Desktop/NEW FINAL/app/src/components/BalticSeaTracker.jsx"],"sourcesContent":["import React, { useEffect, useState, useRef, useCallback, useMemo, memo } from 'react';\nimport { Info, Ship, Menu, ZoomIn, ZoomOut, Radar, Waves, Layers, Wind } from 'lucide-react';\nimport '../styles/palantir-theme.css';\nimport { GoogleMap, useJsApiLoader, Marker, Circle, Polyline, Polygon } from '@react-google-maps/api';\n\n// Add basic CSS styles\nconst styles = {\n  container: {\n    display: 'flex',\n    flexDirection: 'column',\n    height: '100vh',\n    backgroundColor: '#121212'\n  },\n  map: {\n    width: '100%',\n    height: '100vh'\n  },\n  sidebar: {\n    width: '320px',\n    backgroundColor: '#1E1E1E',\n    color: '#FFFFFF',\n    padding: '16px',\n    overflowY: 'auto'\n  },\n  controlPanel: {\n    marginBottom: '16px',\n    padding: '12px',\n    backgroundColor: '#252525',\n    borderRadius: '4px'\n  },\n  buttonActive: {\n    backgroundColor: '#3D85C6',\n    color: 'white',\n    padding: '8px 12px',\n    borderRadius: '4px',\n    border: 'none',\n    marginBottom: '8px',\n    cursor: 'pointer',\n    display: 'flex',\n    alignItems: 'center'\n  },\n  button: {\n    backgroundColor: '#444444',\n    color: 'white',\n    padding: '8px 12px',\n    borderRadius: '4px',\n    border: 'none',\n    marginBottom: '8px',\n    cursor: 'pointer',\n    display: 'flex',\n    alignItems: 'center'\n  },\n  heading: {\n    fontSize: '16px',\n    fontWeight: 'bold',\n    marginBottom: '8px',\n    color: '#3D85C6'\n  },\n  footer: {\n    backgroundColor: '#1E1E1E',\n    color: '#888888',\n    padding: '8px',\n    textAlign: 'center',\n    fontSize: '14px'\n  }\n};\n\n// Memoized components for better performance\nconst MemoizedMarker = memo(Marker);\nconst MemoizedCircle = memo(Circle);\nconst MemoizedPolygon = memo(Polygon);\nconst MemoizedPolyline = memo(Polyline);\n\n// Define container style\nconst mapContainerStyle = {\n  width: '100%',\n  height: '100vh'\n};\n\n// Define center for the Baltic Sea\nconst defaultCenter = {\n  lat: 59,\n  lng: 19\n};\n\nconst BalticSeaTracker = () => {\n  // Use the same API key and configuration that worked in SimpleMap\n  const { isLoaded, loadError } = useJsApiLoader({\n    id: 'google-map-script',\n    googleMapsApiKey: 'AIzaSyAl-iGmFThUduVpLpE7sQTmniBSUPtzJjA',\n    libraries: ['geometry', 'drawing']\n  });\n  \n  console.log(\"Map loading status:\", { isLoaded, loadError });\n\n  const [vessels, setVessels] = useState([]);\n  const [selectedVessel, setSelectedVessel] = useState(null);\n  const [filter, setFilter] = useState('all');\n  const [showSidebar, setShowSidebar] = useState(true);\n  const [displayMode, setDisplayMode] = useState('radar'); // 'radar', 'sonar', or 'fused'\n  const [showWindFarms, setShowWindFarms] = useState(false);\n  const [showRadarCoverage, setShowRadarCoverage] = useState(false); // New state for radar coverage\n  const [showVesselRadar, setShowVesselRadar] = useState(false); // State for vessel radar coverage (300-2999 GT)\n  const [showLargeVesselRadar, setShowLargeVesselRadar] = useState(false); // New state for large vessel radar (>3000 GT)\n  const [mapBounds, setMapBounds] = useState(null); // Track current map bounds\n  const [currentZoom, setCurrentZoom] = useState(6); // Track current zoom level\n  const [mapKey, setMapKey] = useState(Date.now()); // Add key to force remount of map components\n  const [simulationEnabled, setSimulationEnabled] = useState(false); // Track if vessel movement simulation is enabled\n  const [simulationSpeed, setSimulationSpeed] = useState(10); // Simulation speed multiplier (default 10x)\n  const [seaMeshSimulationEnabled, setSeaMeshSimulationEnabled] = useState(false); // Track if SeaMesh simulation is enabled\n  const [simulationStep, setSimulationStep] = useState(0); // Track the current step of the SeaMesh simulation\n  const [warships, setWarships] = useState([]); // Russian warships for the simulation\n  const [detectionRings, setDetectionRings] = useState([]); // Detection events for visualization\n  const animationFrameRef = useRef(null); // Reference to store animation frame ID\n  const lastUpdateTimeRef = useRef(Date.now()); // Reference to store last update time\n  const seaMeshAnimationRef = useRef(null); // Reference for the SeaMesh animation timer\n  \n  const zoomRef = useRef(null);\n  const mapRef = useRef(null);\n  \n  // Google Maps settings\n  const mapCenter = defaultCenter; // Use the default center\n  const mapZoom = 6;\n  \n  // Add state to track current map center\n  const [currentMapCenter, setCurrentMapCenter] = useState(defaultCenter);\n  \n  // Memoize map style to prevent recalculations\n  const mapStyle = useMemo(() => getMapStyle(displayMode), [displayMode]);\n  \n  const mapOptions = useMemo(() => ({\n    disableDefaultUI: true,\n    zoomControl: false,\n    styles: mapStyle,\n    draggable: true, // Ensure map is draggable\n    // Hide cities with population under 5000\n    restrictions: {\n      latLngBounds: {\n        north: 66.0,\n        south: 54.0,\n        east: 30.0,\n        west: 9.0,\n      }\n    }\n  }), [mapStyle]);\n  \n  // Create a ref to track if Google Maps loaded\n  const mapsLoadedRef = useRef(false);\n  \n  // Log any errors with Google Maps loading\n  useEffect(() => {\n    if (loadError) {\n      console.error('Error loading Google Maps:', loadError);\n    }\n    if (isLoaded && !mapsLoadedRef.current) {\n      console.log('Google Maps API loaded successfully');\n      mapsLoadedRef.current = true;\n    }\n  }, [isLoaded, loadError]);\n  \n  // Initialize vessels with mock data\n  useEffect(() => {\n    if (vessels.length === 0) {\n      console.log(\"Initializing mock vessels\");\n      const mockVessels = Array(20).fill(null).map((_, index) => ({\n        id: `mock-vessel-${index}`,\n        name: `Mock Vessel ${index}`,\n        type: ['commercial', 'tanker', 'passenger', 'military'][index % 4],\n        isRussian: index % 5 === 0,\n        position: [\n          // Random positions in the Baltic Sea\n          19 + (Math.random() * 2 - 1), // longitude\n          59 + (Math.random() * 2 - 1)  // latitude\n        ],\n        heading: Math.random() * 360,\n        speed: 10 + Math.random() * 10,\n        flag: index % 5 === 0 ? 'Russia' : 'Sweden',\n        grossTonnage: 300 + Math.floor(Math.random() * 5000)\n      }));\n      \n      setVessels(mockVessels);\n      console.log(\"Mock vessels initialized:\", mockVessels.length);\n    }\n  }, [vessels.length]);\n  \n  // Function to get map style based on display mode\n  function getMapStyle(mode) {\n    switch(mode) {\n      case 'radar':\n        return [\n          { elementType: \"geometry\", stylers: [{ color: \"#212121\" }] },\n          { elementType: \"labels.text.stroke\", stylers: [{ color: \"#212121\" }] },\n          { elementType: \"labels.text.fill\", stylers: [{ color: \"#746855\" }] },\n          { featureType: \"water\", elementType: \"geometry\", stylers: [{ color: \"#181818\" }] },\n          { featureType: \"water\", elementType: \"labels.text.fill\", stylers: [{ color: \"#3d3d3d\" }] },\n          { featureType: \"poi\", stylers: [{ visibility: \"off\" }] },\n          { featureType: \"transit\", stylers: [{ visibility: \"off\" }] },\n          { featureType: \"road\", stylers: [{ visibility: \"off\" }] },\n          // Hide smaller cities/towns\n          { featureType: \"administrative.locality\", elementType: \"labels\", \n            stylers: [{ visibility: \"off\" }] },\n          // Only show major cities\n          { featureType: \"administrative.locality\", elementType: \"labels\", \n            filter: [\">=\", [\"get\", \"population\"], 10000],\n            stylers: [{ visibility: \"on\" }] }\n        ];\n      case 'sonar':\n        return [\n          { elementType: \"geometry\", stylers: [{ color: \"#003545\" }] },\n          { elementType: \"labels.text.stroke\", stylers: [{ color: \"#003545\" }] },\n          { elementType: \"labels.text.fill\", stylers: [{ color: \"#00C8FF\" }] },\n          { featureType: \"water\", elementType: \"geometry\", stylers: [{ color: \"#001E29\" }] },\n          { featureType: \"water\", elementType: \"labels.text.fill\", stylers: [{ color: \"#00E5FF\" }] },\n          { featureType: \"poi\", stylers: [{ visibility: \"off\" }] },\n          { featureType: \"transit\", stylers: [{ visibility: \"off\" }] },\n          { featureType: \"road\", stylers: [{ visibility: \"off\" }] },\n          // Hide smaller cities/towns\n          { featureType: \"administrative.locality\", elementType: \"labels\", \n            stylers: [{ visibility: \"off\" }] },\n          // Only show major cities\n          { featureType: \"administrative.locality\", elementType: \"labels\", \n            filter: [\">=\", [\"get\", \"population\"], 10000],\n            stylers: [{ visibility: \"on\" }] }\n        ];\n      case 'fused':\n        return [\n          { elementType: \"geometry\", stylers: [{ color: \"#142639\" }] },\n          { elementType: \"labels.text.stroke\", stylers: [{ color: \"#142639\" }] },\n          { elementType: \"labels.text.fill\", stylers: [{ color: \"#3D85C6\" }] },\n          { featureType: \"water\", elementType: \"geometry\", stylers: [{ color: \"#0A1C2A\" }] },\n          { featureType: \"water\", elementType: \"labels.text.fill\", stylers: [{ color: \"#4a90e2\" }] },\n          { featureType: \"poi\", stylers: [{ visibility: \"off\" }] },\n          { featureType: \"transit\", stylers: [{ visibility: \"off\" }] },\n          { featureType: \"road\", stylers: [{ visibility: \"off\" }] },\n          // Hide smaller cities/towns\n          { featureType: \"administrative.locality\", elementType: \"labels\", \n            stylers: [{ visibility: \"off\" }] },\n          // Only show major cities\n          { featureType: \"administrative.locality\", elementType: \"labels\", \n            filter: [\">=\", [\"get\", \"population\"], 10000],\n            stylers: [{ visibility: \"on\" }] }\n        ];\n      default:\n        return [];\n    }\n  }\n    \n  // Function to generate a random coordinate within Baltic Sea\n  const randomCoordinate = () => {\n    // Areas to avoid - major inland lakes and problematic areas\n    const avoidAreas = [\n      // Swedish lakes\n      {minLat: 58.0, maxLat: 59.3, minLng: 12.3, maxLng: 14.0}, // Vänern\n      {minLat: 57.7, maxLat: 58.7, minLng: 14.0, maxLng: 14.8}, // Vättern\n      {minLat: 59.1, maxLat: 59.7, minLng: 15.8, maxLng: 18.0}, // Mälaren\n      \n      // Finnish lakes\n      {minLat: 61.0, maxLat: 62.3, minLng: 24.5, maxLng: 26.4}, // Päijänne\n      {minLat: 61.3, maxLat: 63.1, minLng: 26.5, maxLng: 29.0}, // Saimaa\n      \n      // Other inland waters to avoid\n      {minLat: 60.0, maxLat: 61.8, minLng: 29.2, maxLng: 32.0}, // Ladoga\n      {minLat: 57.8, maxLat: 59.0, minLng: 26.5, maxLng: 28.5},  // Peipus\n      \n      // Problematic shore areas - Northern Sweden west coast\n      {minLat: 60.0, maxLat: 65.0, minLng: 17.0, maxLng: 19.5},\n      \n      // Problematic shore areas - Northern Finland west coast\n      {minLat: 63.0, maxLat: 65.5, minLng: 22.5, maxLng: 25.0}\n    ];\n    \n    // Combine shipping lanes with wider dispersal areas\n    const shippingLanes = [\n      // Main shipping lanes (lower weight than before to reduce clustering)\n      // Danish Straits to St. Petersburg\n      {minLat: 54.5, maxLat: 55.2, minLng: 10.8, maxLng: 13.0, weight: 5}, // Danish Straits entrance\n      {minLat: 55.0, maxLat: 55.8, minLng: 12.8, maxLng: 14.5, weight: 4}, // Route east of Denmark\n      {minLat: 55.3, maxLat: 56.2, minLng: 14.5, maxLng: 16.5, weight: 4}, // Southern Sweden coast\n      {minLat: 55.0, maxLat: 56.0, minLng: 16.5, maxLng: 18.5, weight: 3}, // Midway to Gotland\n      {minLat: 57.0, maxLat: 58.2, minLng: 18.5, maxLng: 20.0, weight: 4}, // North of Gotland\n      {minLat: 58.5, maxLat: 59.5, minLng: 20.0, maxLng: 22.0, weight: 3}, // Approach to Gulf of Finland\n      {minLat: 59.2, maxLat: 59.8, minLng: 22.0, maxLng: 24.5, weight: 5}, // Gulf of Finland western part\n      {minLat: 59.7, maxLat: 60.2, minLng: 24.5, maxLng: 28.0, weight: 4}, // Gulf of Finland eastern part\n      \n      // Port approaches - reduced weights to prevent clustering\n      {minLat: 60.0, maxLat: 60.5, minLng: 24.5, maxLng: 25.0, weight: 3}, // Helsinki\n      {minLat: 60.2, maxLat: 60.5, minLng: 22.0, maxLng: 22.5, weight: 3}, // Turku\n      {minLat: 55.3, maxLat: 56.3, minLng: 12.5, maxLng: 13.0, weight: 3}, // Malmö\n      {minLat: 58.5, maxLat: 59.5, minLng: 16.5, maxLng: 18.5, weight: 3}, // Stockholm\n      {minLat: 54.3, maxLat: 54.8, minLng: 18.3, maxLng: 19.0, weight: 3}, // Gdańsk\n      {minLat: 54.0, maxLat: 54.5, minLng: 13.0, maxLng: 14.5, weight: 3}, // Rostock\n      \n      // Wider dispersal areas - these ensure ships are spread throughout the entire sea\n      // Central Baltic - large dispersal areas\n      {minLat: 56.0, maxLat: 58.0, minLng: 17.0, maxLng: 20.0, weight: 5}, // Central Baltic wider area\n      {minLat: 57.5, maxLat: 59.5, minLng: 19.0, maxLng: 22.0, weight: 5}, // Eastern Baltic wider area\n      \n      // Gulf of Bothnia - more dispersed\n      {minLat: 60.0, maxLat: 62.0, minLng: 18.0, maxLng: 21.0, weight: 4}, // Southern Bothnia dispersed\n      {minLat: 62.0, maxLat: 65.0, minLng: 18.0, maxLng: 23.0, weight: 3}, // Northern Bothnia dispersed\n      \n      // Western Baltic - more dispersed\n      {minLat: 54.0, maxLat: 56.0, minLng: 12.0, maxLng: 15.0, weight: 4}, // Western Baltic dispersed\n      {minLat: 54.0, maxLat: 57.0, minLng: 15.0, maxLng: 18.0, weight: 5}, // South-central Baltic dispersed\n      \n      // Other dispersed areas to ensure wider coverage\n      {minLat: 54.0, maxLat: 55.5, minLng: 18.0, maxLng: 20.0, weight: 3}, // Southern Baltic dispersed\n      {minLat: 56.5, maxLat: 58.0, minLng: 15.0, maxLng: 17.0, weight: 3}, // Western Gotland dispersed\n      {minLat: 57.0, maxLat: 58.5, minLng: 20.0, maxLng: 22.0, weight: 3}, // Eastern Gotland dispersed\n      {minLat: 57.0, maxLat: 58.5, minLng: 22.0, maxLng: 24.0, weight: 3}, // Gulf of Riga dispersed\n    ];\n    \n    // Calculate total weight\n    const totalWeight = shippingLanes.reduce((sum, lane) => sum + lane.weight, 0);\n    \n    // Pick a random lane with weighting\n    let randomPoint = Math.random() * totalWeight;\n    let selectedLane = shippingLanes[0];\n    let cumulativeWeight = 0;\n    \n    for (const lane of shippingLanes) {\n      cumulativeWeight += lane.weight;\n      if (randomPoint <= cumulativeWeight) {\n        selectedLane = lane;\n        break;\n      }\n    }\n    \n    // Generate random point\n    const lng = selectedLane.minLng + Math.random() * (selectedLane.maxLng - selectedLane.minLng);\n    const lat = selectedLane.minLat + Math.random() * (selectedLane.maxLat - selectedLane.minLat);\n    \n    // Check if the generated point is in an area to avoid\n    for (const area of avoidAreas) {\n      if (lat >= area.minLat && lat <= area.maxLat && lng >= area.minLng && lng <= area.maxLng) {\n        // If in an avoid area, recursively try again (with a maximum call stack check)\n        // This ensures we don't get stuck in an infinite loop\n        if (randomCoordinate.callCount === undefined) {\n          randomCoordinate.callCount = 0;\n        }\n        \n        if (randomCoordinate.callCount < 10) {\n          randomCoordinate.callCount++;\n          const result = randomCoordinate();\n          randomCoordinate.callCount--;\n          return result;\n        } else {\n          // If we've tried too many times, just use a safe zone in the central Baltic\n          randomCoordinate.callCount = 0;\n          return [18.5 + Math.random() * 2, 56.5 + Math.random() * 2]; // Safe zone in central Baltic\n        }\n      }\n    }\n    \n    // Reset call count\n    if (randomCoordinate.callCount !== undefined) {\n      randomCoordinate.callCount = 0;\n    }\n    \n    // Return the coordinates\n    return [lng, lat];\n  };\n  \n  // Generate 300 simulated vessels with realistic properties (reduced from 1000)\n  const generateVessels = useCallback(() => {\n    const vesselTypes = ['commercial', 'military', 'fishing', 'passenger', 'tanker'];\n    const flags = ['Finland', 'Sweden', 'Estonia', 'Latvia', 'Lithuania', 'Poland', 'Germany', 'Denmark', 'Russia'];\n    const russianOperators = ['Sovcomflot', 'Gazprom Fleet', 'Rosmorport', 'Russian Navy', 'Rosneft'];\n    const commercialOperators = ['Maersk', 'MSC', 'CMA CGM', 'Hapag-Lloyd', 'ONE', 'Evergreen', 'COSCO', \n                                'Yang Ming', 'HMM', 'Grimaldi', 'DFDS', 'Stena Line', 'Tallink', 'Viking Line'];\n    \n    // Generate vessels with better dispersal throughout the Baltic Sea\n    const generatedVessels = [];\n    const occupiedPositions = []; // Track positions to ensure better dispersal\n    const MIN_DISTANCE = 0.2; // Minimum distance between vessels in degrees (approx 10-20km)\n    \n    // Start with fewer vessels and then disperse them more effectively\n    const maxAttempts = 600; // Increase attempts to find valid positions\n    let placedVesselCount = 0;\n    \n    // Try to place vessels with appropriate spacing\n    for (let i = 1; placedVesselCount < 300 && i <= maxAttempts; i++) {\n      const type = vesselTypes[Math.floor(Math.random() * vesselTypes.length)];\n      const flag = flags[Math.floor(Math.random() * flags.length)];\n      const isRussian = flag === 'Russia' || (Math.random() < 0.05); // 5% chance of non-Russian flag but Russian operated\n      \n      // Get a potential position for the vessel\n      const position = randomCoordinate();\n      \n      // Skip positions that are not in Baltic Sea water\n      if (!isInBalticSeaWaters(position[1], position[0])) {\n        continue;\n      }\n      \n      // Check if this position is too close to existing vessels\n      let isTooClose = false;\n      for (const existingPos of occupiedPositions) {\n        const distance = Math.sqrt(\n          Math.pow(position[0] - existingPos[0], 2) + \n          Math.pow(position[1] - existingPos[1], 2)\n        );\n        \n        if (distance < MIN_DISTANCE) {\n          isTooClose = true;\n          break;\n        }\n      }\n      \n      // If the position is too close to other vessels, skip this attempt\n      if (isTooClose) {\n        continue;\n      }\n      \n      // If we got here, the position is good, so add it to occupied positions\n      occupiedPositions.push(position);\n      placedVesselCount++;\n      \n      // Calculate a more realistic heading based on position\n      // Ships in the Baltic generally move east-west in southern parts, and north-south in gulfs\n      let heading;\n      const vesselLat = position[1];\n      const vesselLng = position[0];\n      \n      // Baltic shipping lane direction tendencies\n      if (vesselLng < 14.0) {\n        // Danish straits and western Baltic - generally east/west traffic\n        heading = Math.random() < 0.7 ? 70 + Math.random() * 40 : 250 + Math.random() * 40;\n      } else if (vesselLng > 23.0 && vesselLat > 59.0) {\n        // Gulf of Finland - generally east/west traffic\n        heading = Math.random() < 0.5 ? 80 + Math.random() * 30 : 260 + Math.random() * 30;\n      } else if (vesselLng > 19.0 && vesselLat > 60.0) {\n        // Gulf of Bothnia - generally north/south traffic\n        heading = Math.random() < 0.5 ? 0 + Math.random() * 30 : 180 + Math.random() * 30;\n      } else if (vesselLng > 22.0 && vesselLat < 58.0 && vesselLat > 56.5) {\n        // Gulf of Riga - generally north/south traffic\n        heading = Math.random() < 0.5 ? 0 + Math.random() * 40 : 180 + Math.random() * 40;\n      } else if (vesselLat < 56.0 && vesselLng > 18.0) {\n        // Southern Baltic to Polish/Lithuanian ports\n        heading = Math.random() < 0.6 ? 140 + Math.random() * 40 : 320 + Math.random() * 40;\n      } else {\n        // Central Baltic - mixed traffic patterns\n        heading = Math.floor(Math.random() * 360);\n      }\n      \n      // Realistic speed based on vessel type and weather (assumed normal conditions)\n      let speed;\n      if (type === 'commercial' || type === 'tanker') {\n        speed = 10 + Math.floor(Math.random() * 8); // 10-18 knots\n      } else if (type === 'passenger') {\n        speed = 15 + Math.floor(Math.random() * 10); // 15-25 knots\n      } else if (type === 'military') {\n        speed = 5 + Math.floor(Math.random() * 25); // 5-30 knots (more variable)\n      } else if (type === 'fishing') {\n        // Fishing vessels move slower or may be stationary when fishing\n        speed = Math.random() < 0.3 ? 0 : 5 + Math.floor(Math.random() * 7); // 0 or 5-12 knots\n      } else {\n        speed = Math.floor(Math.random() * 15) + 5; // 5-20 knots default\n      }\n      \n      // Determine vessel size\n      const length = type === 'tanker' || type === 'commercial' \n        ? 100 + Math.floor(Math.random() * 300) \n        : type === 'military' \n          ? 50 + Math.floor(Math.random() * 200)\n          : 20 + Math.floor(Math.random() * 50);\n      \n      // Calculate gross tonnage (GT) based on vessel length and type\n      // Using simplified formula based on vessel dimensions\n      let grossTonnage;\n      if (type === 'commercial' || type === 'tanker') {\n        // Commercial and tanker vessels have higher GT/length ratios\n        grossTonnage = Math.round(length * length * 0.18); // Approximation\n      } else if (type === 'military') {\n        // Military vessels are typically more dense but smaller\n        grossTonnage = Math.round(length * length * 0.16);\n      } else if (type === 'passenger') {\n        // Passenger vessels have high volume and less dense cargo\n        grossTonnage = Math.round(length * length * 0.2);\n      } else {\n        // Fishing and other vessels\n        grossTonnage = Math.round(length * length * 0.12);\n      }\n      \n      // Determine operator\n      let operator;\n      if (isRussian) {\n        operator = russianOperators[Math.floor(Math.random() * russianOperators.length)];\n      } else {\n        operator = commercialOperators[Math.floor(Math.random() * commercialOperators.length)];\n      }\n      \n      // Generate a realistic vessel name\n      const prefixes = isRussian ? \n        ['Admiral', 'Kapitan', 'Vostok', 'Sibir', 'Moskva', 'Sankt-Peterburg', 'Akademik'] : \n        ['Northern', 'Baltic', 'Sea', 'Atlantic', 'Pacific', 'Star', 'Pioneer'];\n      \n      const suffixes = isRussian ?\n        ['Kuznetsov', 'Nakhimov', 'Gorshkov', 'Lazarev', 'Kasatonov', 'Ustinov'] :\n        ['Adventurer', 'Explorer', 'Navigator', 'Voyager', 'Mariner', 'Trader', 'Express'];\n        \n      const shipNumbers = ['I', 'II', 'III', 'IV', 'V', '1', '2', '3', '4', '5'];\n      \n      let name;\n      if (Math.random() < 0.3) {\n        // 30% chance of having a prefix-suffix name\n        name = `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;\n      } else if (Math.random() < 0.5) {\n        // 20% chance of having a name with a number\n        name = `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${shipNumbers[Math.floor(Math.random() * shipNumbers.length)]}`;\n      } else {\n        // 50% chance of having a simple prefix or suffix name\n        name = Math.random() < 0.5 ? \n          prefixes[Math.floor(Math.random() * prefixes.length)] : \n          suffixes[Math.floor(Math.random() * suffixes.length)];\n      }\n      \n      if (type === 'military' && isRussian) {\n        name = `RFS ${name}`; // Russian Federation Ship\n      }\n      \n      // Calculate a detection probability\n      const detectionProbability = {\n        radar: Math.random(), // 0-1, higher means more visible on radar\n        sonar: Math.random(), // 0-1, higher means more detectable by sonar\n        fused: (Math.random() + Math.random()) / 2 // average of two values for a more normal distribution\n      };\n      \n      // Generate a vessel object with all properties\n      generatedVessels.push({\n        id: placedVesselCount,\n        name,\n        type,\n        flag,\n        isRussian,\n        position,\n        heading,\n        speed,\n        length,\n        operator,\n        detectionProbability,\n        grossTonnage\n      });\n    }\n    \n    // More evenly disperse submarines too\n    // Generate Russian submarines with special characteristics\n    const submarineNames = [\n      'Krasnodar', 'Novorossiysk', 'Rostov-on-Don', 'Stary Oskol', \n      'Velikiy Novgorod', 'Kolpino', 'Sankt Peterburg'\n    ];\n    \n    const submarineClasses = [\n      'Kilo-class', 'Kilo-class', 'Kilo-class', 'Kilo-class',\n      'Improved Kilo-class', 'Improved Kilo-class', 'Lada-class'\n    ];\n    \n    const submarineDesignations = [\n      'B-265', 'B-261', 'B-237', 'B-262', \n      'B-268', 'B-271', 'B-585'\n    ];\n    \n    // Use more strategic submarine positions\n    const submarineAreas = [\n      // Gulf of Finland approach - monitoring traffic to St. Petersburg\n      [26.2, 59.7],\n      // Near NATO naval exercise areas in central Baltic\n      [19.3, 56.8],\n      // Monitoring approach to Stockholm archipelago\n      [18.9, 58.9],\n      // Deep water between Gotland and Latvia (strategic position)\n      [20.1, 57.3],\n      // Patrolling near Kaliningrad naval base\n      [19.6, 55.2],\n      // Monitoring naval traffic near Gdańsk\n      [18.8, 54.8],\n      // Danish straits approaches - key strategic chokepoint\n      [12.8, 55.4]\n    ];\n    \n    // Add some randomness to submarine positions to avoid perfect predictability\n    const randomizedSubmarineAreas = submarineAreas.map(pos => [\n      pos[0] + (Math.random() - 0.5) * 0.5,  // Add up to ±0.25 degrees longitude\n      pos[1] + (Math.random() - 0.5) * 0.3   // Add up to ±0.15 degrees latitude\n    ]);\n    \n    // Add submarines to generated vessels\n    for (let i = 0; i < 7; i++) {\n      const position = randomizedSubmarineAreas[i];\n      \n      // Skip submarine positions that aren't in Baltic Sea water\n      if (!isInBalticSeaWaters(position[1], position[0])) {\n        // Try to find a better position by adjusting slightly\n        for (let attempt = 0; attempt < 5; attempt++) {\n          // Try adjusting position slightly to find water\n          const adjustedPosition = [\n            position[0] + (Math.random() - 0.5) * 0.5,\n            position[1] + (Math.random() - 0.5) * 0.5\n          ];\n          \n          if (isInBalticSeaWaters(adjustedPosition[1], adjustedPosition[0])) {\n            // Found a valid position\n            position[0] = adjustedPosition[0];\n            position[1] = adjustedPosition[1];\n            break;\n          }\n        }\n        \n        // If still not in water after adjustments, skip this submarine\n        if (!isInBalticSeaWaters(position[1], position[0])) {\n          continue;\n        }\n      }\n      \n      const heading = Math.floor(Math.random() * 360);\n      const speed = 5 + Math.floor(Math.random() * 10); // Submarines move slower on average\n      const depth = 20 + Math.floor(Math.random() * 180); // Depth in meters\n      \n      // Submarine detection characteristics\n      // Low radar detection when submerged, high sonar signature\n      const isSubmerged = Math.random() > 0.3; // 70% chance of being submerged\n      \n      const detectionProbability = {\n        radar: isSubmerged ? 0.05 + Math.random() * 0.1 : 0.3 + Math.random() * 0.2, // Low radar when submerged\n        sonar: 0.6 + Math.random() * 0.4, // High sonar signature\n        fused: isSubmerged ? \n          (0.05 + Math.random() * 0.1 + 0.6 + Math.random() * 0.4) / 2 : // Average when submerged\n          (0.3 + Math.random() * 0.2 + 0.6 + Math.random() * 0.4) / 2    // Average when surfaced\n      };\n      \n      generatedVessels.push({\n        id: 1001 + i, // IDs starting from 1001 for submarines\n        name: `RFS ${submarineNames[i]}`,\n        type: 'submarine',\n        class: submarineClasses[i],\n        designation: submarineDesignations[i],\n        flag: 'Russia',\n        isRussian: true,\n        position,\n        heading,\n        speed,\n        depth,\n        length: 70 + Math.floor(Math.random() * 20), // Kilo-class submarines are around 70-74m\n        isSubmerged,\n        operator: 'Russian Navy',\n        detectionProbability\n      });\n    }\n    \n    return generatedVessels;\n  }, []);\n  \n  // Generate vessel data when component mounts\n  useEffect(() => {\n    const simulatedVessels = generateVessels();\n    setVessels(simulatedVessels);\n  }, [generateVessels]);\n  \n  // Update vessel positions based on speed and heading\n  const updateVesselPositions = useCallback(() => {\n    if (!simulationEnabled) return;\n    \n    const currentTime = Date.now();\n    const deltaTime = (currentTime - lastUpdateTimeRef.current) / 1000; // Convert ms to seconds\n    lastUpdateTimeRef.current = currentTime;\n    \n    // Apply speed multiplier to deltaTime\n    const adjustedDeltaTime = deltaTime * simulationSpeed;\n    \n    // Skip if delta time is too large (e.g., browser tab was inactive)\n    if (adjustedDeltaTime > 5) return;\n    \n    setVessels(prevVessels => {\n      return prevVessels.map(vessel => {\n        // Skip stationary vessels\n        if (vessel.speed === 0) return vessel;\n        \n        // Convert knots to degrees per second\n        // 1 knot ≈ 0.0003 degrees of longitude at the equator per second\n        // Adjust for latitude (narrower longitude degrees at higher latitudes)\n        const latitudeAdjustment = Math.cos(vessel.position[1] * Math.PI / 180);\n        const longitudeChange = vessel.speed * 0.0003 * adjustedDeltaTime / latitudeAdjustment;\n        const latitudeChange = vessel.speed * 0.0003 * adjustedDeltaTime;\n        \n        // Calculate new position based on heading\n        const headingRad = vessel.heading * Math.PI / 180;\n        const newLng = vessel.position[0] + (longitudeChange * Math.sin(headingRad));\n        const newLat = vessel.position[1] + (latitudeChange * Math.cos(headingRad));\n        \n        // Enhanced boundary checking to keep vessels within the actual Baltic Sea water\n        if (!isInBalticSeaWaters(newLat, newLng)) {\n          // If would move onto land or out of bounds, adjust heading to turn back toward deeper water\n          // Use a more detailed approach to find the right direction\n          \n          // Try finding a better direction by checking multiple angles\n          let bestHeading = vessel.heading;\n          let foundBetterDirection = false;\n          \n          // Check 8 directions around to find waters\n          for (let angleOffset = 0; angleOffset < 360; angleOffset += 45) {\n            const testHeading = (vessel.heading + angleOffset) % 360;\n            const testRad = testHeading * Math.PI / 180;\n            \n            // Check a position further out in this direction\n            const testLng = vessel.position[0] + (longitudeChange * 5 * Math.sin(testRad));\n            const testLat = vessel.position[1] + (latitudeChange * 5 * Math.cos(testRad));\n            \n            if (isInBalticSeaWaters(testLat, testLng)) {\n              bestHeading = testHeading;\n              foundBetterDirection = true;\n              break;\n            }\n          }\n          \n          // If no good direction found, head toward the Baltic center\n          if (!foundBetterDirection) {\n            const centerLat = 58.5; // More centered in the main Baltic basin\n            const centerLng = 20;   // Adjusted to be in deeper waters\n            const angleToCenter = Math.atan2(centerLng - vessel.position[0], centerLat - vessel.position[1]) * 180 / Math.PI;\n            \n            // Turn gradually toward the center\n            const headingDiff = ((angleToCenter - vessel.heading + 540) % 360) - 180;\n            bestHeading = (vessel.heading + Math.sign(headingDiff) * 45) % 360;\n            if (bestHeading < 0) bestHeading += 360;\n          }\n          \n          // Slow down near boundaries\n          const reducedSpeed = Math.max(1, vessel.speed * 0.5);\n          \n          return {\n            ...vessel,\n            heading: bestHeading,\n            speed: reducedSpeed // Temporarily reduce speed when changing course\n          };\n        }\n        \n        // For military and submarine vessels, randomly change heading occasionally\n        let newHeading = vessel.heading;\n        const originalSpeed = vessel.speed;\n        let newSpeed = originalSpeed;\n        \n        if ((vessel.type === 'military' || vessel.type === 'submarine') && Math.random() < 0.01 * adjustedDeltaTime) {\n          // Change heading by up to +/- 30 degrees\n          newHeading = (vessel.heading + (Math.random() * 60 - 30)) % 360;\n          if (newHeading < 0) newHeading += 360;\n          \n          // Military vessels might change speed during maneuvers\n          if (Math.random() < 0.3) {\n            const speedFactor = 0.7 + Math.random() * 0.6; // 70-130% of current speed\n            newSpeed = Math.max(1, Math.min(30, originalSpeed * speedFactor));\n          }\n        }\n        // Smaller random heading changes for other vessels to simulate realistic movement\n        else if (Math.random() < 0.005 * adjustedDeltaTime) {\n          // Change heading by up to +/- 10 degrees\n          newHeading = (vessel.heading + (Math.random() * 20 - 10)) % 360;\n          if (newHeading < 0) newHeading += 360;\n        }\n        \n        // Final position check - ensure vessel doesn't go on land even after all other checks\n        const finalLng = newLng;\n        const finalLat = newLat;\n        \n        // If vessel would end up on land, don't update position but keep the heading change\n        if (!isInBalticSeaWaters(finalLat, finalLng)) {\n          return {\n            ...vessel,\n            heading: newHeading,\n            speed: newSpeed\n          };\n        }\n        \n        // Special check for Swedish coastline (which seems particularly problematic)\n        // These bounds roughly define the Swedish coastline area\n        const isNearSwedishCoast = (\n          (finalLat >= 55.0 && finalLat <= 60.0 && finalLng >= 12.0 && finalLng <= 19.0) &&\n          // Distance to coast is small\n          ((finalLng >= 12.0 && finalLng <= 14.0) || // Western coast\n           (finalLat >= 58.0 && finalLat <= 60.0 && finalLng >= 16.5 && finalLng <= 19.0) || // Stockholm area\n           (finalLat >= 56.0 && finalLat <= 58.0 && finalLng >= 15.5 && finalLng <= 17.0)) // Eastern coast\n        );\n        \n        // For vessels near Swedish coast, make extra check by testing multiple points\n        if (isNearSwedishCoast && Math.random() < 0.7) { // 70% extra caution near Swedish coast\n          const currentPos = vessel.position;\n          const distance = Math.sqrt(\n            Math.pow(finalLng - currentPos[0], 2) + \n            Math.pow(finalLat - currentPos[1], 2)\n          );\n          \n          // If making a significant move near Swedish coast, stay put instead of risking land\n          if (distance > 0.02) {\n            return {\n              ...vessel,\n              heading: newHeading,\n              speed: Math.max(1, newSpeed * 0.5) // Reduce speed near coast\n            };\n          }\n        }\n        \n        return {\n          ...vessel,\n          position: [finalLng, finalLat],\n          heading: newHeading,\n          speed: newSpeed\n        };\n      });\n    });\n    \n    // Request next animation frame\n    animationFrameRef.current = requestAnimationFrame(updateVesselPositions);\n  }, [simulationEnabled, simulationSpeed]);\n  \n  // Function to check if a point is in Baltic Sea waters\n  // This is a more precise check than just the bounding box\n  const isInBalticSeaWaters = useCallback((lat, lng) => {\n    // First check overall bounds\n    if (lat < 54.0 || lat > 66.0 || lng < 9.0 || lng > 30.0) {\n      return false;\n    }\n    \n    // Define areas that are land (to be avoided)\n    // Format: [south, north, west, east]\n    const landAreas = [\n      // Southern Sweden - expanded and more precise with additional coverage\n      [55.0, 59.5, 12.5, 16.0],\n      // Southern Sweden - additional western coast coverage\n      [56.0, 58.8, 11.5, 13.0],\n      // Stockholm archipelago area - more precise\n      [59.0, 60.0, 17.0, 19.2],\n      // Sweden central eastern coast - additional coverage\n      [58.0, 59.5, 16.0, 17.8],\n      // Northern Sweden - Gulf of Bothnia coastline\n      [60.0, 63.0, 17.0, 19.5],\n      // Northern Sweden - upper Gulf of Bothnia\n      [63.0, 65.5, 17.0, 22.0],\n      // Northern Sweden - northwestern area\n      [64.0, 66.0, 15.0, 17.0],\n      // Finland - expanded\n      [59.7, 65.5, 21.0, 30.0],\n      // Estonia - expanded\n      [57.5, 59.7, 22.8, 28.5],\n      // Latvia/Lithuania coast - expanded\n      [55.5, 57.5, 20.8, 28.0],\n      // Poland inland - expanded\n      [54.0, 55.5, 14.8, 19.8],\n      // Germany/Denmark inland - expanded\n      [54.0, 56.5, 9.0, 12.0],\n      // Gotland - more precise\n      [56.8, 58.0, 18.0, 19.2],\n      // Åland Islands - expanded\n      [59.7, 60.5, 19.3, 21.3],\n      // Bornholm - more precise\n      [54.9, 55.3, 14.7, 15.2],\n      // Öland\n      [56.1, 57.5, 16.3, 17.1],\n      // Rügen\n      [54.2, 54.7, 13.0, 13.6],\n      // Saaremaa\n      [57.8, 58.7, 21.7, 23.0],\n      // Hiiumaa\n      [58.7, 59.1, 22.0, 23.0],\n      // Inland lakes in Finland\n      [61.0, 63.0, 25.0, 30.0],\n      // Kaliningrad and surrounding area\n      [54.3, 55.3, 19.6, 22.5]\n    ];\n    \n    // Define key shipping channels and deep waters (preferred areas)\n    // Format: [south, north, west, east, weight]\n    const shippingChannels = [\n      // Main Baltic basin\n      [55.5, 59.0, 16.5, 22.0, 10],\n      // Gulf of Finland shipping lane\n      [59.3, 60.2, 22.5, 28.0, 8],\n      // Approach to Stockholm\n      [58.7, 59.5, 17.5, 19.5, 6],\n      // Approach to Riga\n      [56.8, 58.0, 22.5, 24.5, 6],\n      // Approach to Helsinki/Tallinn\n      [59.2, 59.9, 24.0, 25.5, 8],\n      // Western Baltic shipping lane\n      [54.5, 56.0, 12.0, 15.0, 8],\n      // Kattegat\n      [56.0, 57.5, 10.5, 12.0, 6],\n      // Gulf of Bothnia\n      [60.5, 63.5, 18.5, 21.5, 5],\n      // Central Baltic - expanded to cover more water\n      [56.0, 59.0, 17.5, 21.0, 10],\n      // Southern Baltic - expanded\n      [54.5, 56.5, 15.0, 19.0, 8]\n    ];\n    \n    // Check if point is in a land area - more strict checking\n    for (const [south, north, west, east] of landAreas) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // Further check for complex coastlines\n        // This is a very simplified approach - we add some randomness \n        // to prevent vessels from getting stuck at sharp boundary transitions\n        \n        // If near the edge of a land area, there's a small chance to still consider it water\n        // This helps vessels navigate around complex coastlines without getting stuck\n        const distanceFromEdge = Math.min(\n          Math.abs(lat - south),\n          Math.abs(lat - north),\n          Math.abs(lng - west),\n          Math.abs(lng - east)\n        );\n        \n        // Very close to edge - might be a complex coastline\n        if (distanceFromEdge < 0.1) {\n          // 15% chance to consider it water if very close to edge (reduced from 20%)\n          // This randomness helps prevent getting stuck at boundaries\n          return Math.random() < 0.15;\n        }\n        \n        return false; // It's in a land area\n      }\n    }\n\n    // Check if in a preferred shipping channel\n    for (const [south, north, west, east] of shippingChannels) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        return true; // In a shipping channel - definitely good\n      }\n    }\n    \n    // For areas not explicitly defined, use the following general rules\n    \n    // Avoid shallow coastal waters (simplified approach)\n    // These are general buffer zones around landmasses\n    const coastalBuffers = [\n      // Swedish coast buffer - expanded\n      [55.0, 59.5, 14.8, 16.5],\n      // Swedish west coast buffer\n      [56.0, 58.8, 11.0, 12.2],\n      // Swedish eastern coastline\n      [58.0, 59.5, 16.0, 17.0],\n      // Northern Sweden - Gulf of Bothnia western coast\n      [60.0, 63.0, 19.0, 20.0],\n      // Northern Sweden - upper coast\n      [63.0, 65.5, 19.5, 22.5],\n      // Finnish coast buffer\n      [59.7, 65.5, 20.0, 21.5],\n      // Estonian coast buffer\n      [57.5, 59.7, 22.0, 23.0],\n      // Latvian/Lithuanian coast buffer\n      [55.5, 57.5, 19.5, 21.5],\n      // Polish coast buffer\n      [54.0, 55.5, 14.0, 15.5],\n      // German/Danish coast buffer\n      [54.0, 56.0, 12.0, 13.0]\n    ];\n    \n    // Check coastal buffers with higher probability of rejection\n    for (const [south, north, west, east] of coastalBuffers) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 80% chance to consider coastal buffers as land (increased from 70%)\n        return Math.random() > 0.8;\n      }\n    }\n    \n    // Special check for Swedish coastal waters - these are problematic\n    const swedishProblemAreas = [\n      // Stockholm archipelago approaches\n      [58.8, 59.5, 17.5, 19.0],\n      // Swedish eastern coastline near Öland\n      [56.5, 57.5, 16.0, 16.8],\n      // Swedish western approaches\n      [57.0, 58.5, 11.2, 12.5],\n      // Northern Sweden Gulf of Bothnia western coast\n      [60.0, 63.0, 18.5, 20.0],\n      // Northern Sweden - northeastern area\n      [63.0, 65.0, 19.0, 22.0]\n    ];\n    \n    // Higher rejection rate specifically for Swedish coastal waters\n    for (const [south, north, west, east] of swedishProblemAreas) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 90% chance to reject - very strict for Swedish waters\n        return Math.random() > 0.9;\n      }\n    }\n    \n    // Additional check for enclosed bays and lakes\n    // Define problematic enclosed areas (small bays, inlets, etc.)\n    const problematicAreas = [\n      // Finnish inland lake areas \n      [60.7, 62.5, 23.0, 29.0],\n      // Swedish lake areas\n      [58.5, 59.5, 14.0, 16.0],\n      // Various small bays and inlets\n      [57.2, 57.6, 16.8, 17.2], // Near Öland\n      [60.0, 60.2, 24.8, 25.2], // Helsinki area\n      [58.8, 59.0, 17.5, 18.0], // Stockholm archipelago\n      [58.1, 58.5, 11.5, 12.0]  // Skagerrak entrance\n    ];\n    \n    // Higher chance to reject problematic areas\n    for (const [south, north, west, east] of problematicAreas) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 60% chance to reject\n        return Math.random() > 0.6;\n      }\n    }\n    \n    // Explicitly define major lakes to avoid them completely\n    const majorLakes = [\n      // Swedish lakes\n      [58.0, 59.3, 12.3, 14.0], // Vänern\n      [57.7, 58.7, 14.0, 14.8], // Vättern\n      [59.1, 59.7, 15.8, 18.0], // Mälaren\n      [56.9, 57.5, 13.4, 14.8], // Southern Swedish lakes\n      [56.8, 57.2, 14.4, 15.2], // Åsnen and nearby lakes\n      \n      // Finnish lakes\n      [61.0, 62.3, 24.5, 26.4], // Päijänne and nearby\n      [61.3, 63.1, 26.5, 29.0], // Saimaa system\n      [62.0, 63.7, 23.0, 24.5], // Western Finnish lakes\n      [61.5, 62.2, 28.5, 29.8], // Eastern Finnish lakes\n      [60.3, 60.8, 23.5, 25.0], // Southern Finnish lakes\n      \n      // Russian lakes\n      [60.0, 61.8, 29.2, 32.0], // Ladoga\n      [60.0, 60.8, 27.4, 29.0], // Eastern Gulf of Finland lakes\n      [57.8, 59.0, 26.5, 28.5], // Peipus\n      \n      // Other inland waters\n      [54.1, 54.7, 17.8, 18.7], // Polish lakes\n      [53.5, 54.3, 12.0, 14.0], // German lakes\n      [53.8, 55.0, 10.2, 11.0], // Danish inland waters\n      [55.5, 56.5, 9.5, 10.2]   // Limfjord area\n    ];\n    \n    // Strict rejection of major lakes - almost never allow vessels here\n    for (const [south, north, west, east] of majorLakes) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        // 99.5% chance to consider these as land - essentially never allow vessels in lakes\n        return Math.random() > 0.995;\n      }\n    }\n    \n    // Known safe water zones - replaced with enhanced version\n    const safeWaterZones = [\n      // Central Baltic open water\n      [56.5, 58.5, 18.0, 21.0],\n      // Eastern Baltic open water\n      [57.0, 59.0, 20.0, 22.0],\n      // Western Baltic open water\n      [55.0, 56.5, 13.0, 15.0],\n      // Southern Baltic deep water\n      [54.5, 55.5, 16.0, 18.5],\n      // Gulf of Finland central channel\n      [59.4, 60.0, 23.0, 27.0],\n      // Gulf of Bothnia southern part - central channel\n      [60.5, 62.5, 20.0, 21.0],\n      // Gulf of Bothnia central part - central channel\n      [62.5, 64.0, 20.2, 21.2],\n      // Gulf of Bothnia northern part - central channel\n      [64.0, 65.0, 21.5, 22.5]\n    ];\n    \n    // If in a known safe water zone, it's definitely water\n    for (const [south, north, west, east] of safeWaterZones) {\n      if (lat >= south && lat <= north && lng >= west && lng <= east) {\n        return true;\n      }\n    }\n    \n    // Special check for northern Gulf of Bothnia - narrower channel\n    if (lat >= 63.0 && lat <= 65.5 && lng >= 20.0 && lng <= 22.0) {\n      // In the narrower northern part of Gulf of Bothnia, be more restrictive\n      // Only consider central waters as safe (within 0.3° from center line)\n      const centerLng = 21.0;\n      const distanceFromCenter = Math.abs(lng - centerLng);\n      \n      if (distanceFromCenter < 0.3) {\n        return true; // Central channel\n      } else if (distanceFromCenter < 0.5) {\n        // In the transition zone, random chance to allow\n        return Math.random() > 0.7;\n      } else {\n        // Too close to shore\n        return Math.random() > 0.95; // Very small chance to consider as water\n      }\n    }\n    \n    // If we got here, it's probably in open water\n    return true;\n  }, []);\n  \n  // Start/stop vessel position updates when simulation state changes\n  useEffect(() => {\n    if (simulationEnabled) {\n      lastUpdateTimeRef.current = Date.now();\n      animationFrameRef.current = requestAnimationFrame(updateVesselPositions);\n    } else if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    \n    // Cleanup when component unmounts\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [simulationEnabled, updateVesselPositions]);\n  \n  // Function to check if an item is in the current map bounds\n  const isInMapBounds = useCallback((lat, lng) => {\n    if (!mapBounds) return true; // If no bounds yet, show everything\n    \n    // Add buffer to avoid popping at edges\n    const buffer = 0.5; // Buffer in degrees\n    \n    return (\n      lat >= mapBounds.south - buffer &&\n      lat <= mapBounds.north + buffer &&\n      lng >= mapBounds.west - buffer &&\n      lng <= mapBounds.east + buffer\n    );\n  }, [mapBounds]);\n  \n  // Simple implementation of renderVessels\n  const renderVessels = useCallback(() => {\n    console.log(`Rendering ${vessels.length} vessels`);\n    \n    if (vessels.length === 0) {\n      console.log(\"No vessels to render\");\n      return null;\n    }\n    \n    return vessels.map(vessel => {\n      if (!vessel.position || vessel.position.length < 2) {\n        console.log(\"Invalid vessel position:\", vessel);\n        return null;\n      }\n      \n      const position = { lat: vessel.position[1], lng: vessel.position[0] };\n      \n      // Simple marker for vessels\n      return (\n        <MemoizedMarker\n          key={vessel.id}\n          position={position}\n          icon={{\n            path: \"M -1,1 L 1,1 L 1,-1 L -1,-1 Z\", // Simple square\n            fillColor: vessel.isRussian ? 'rgb(231, 76, 60)' : 'rgb(52, 152, 219)',\n            fillOpacity: 0.8,\n            strokeColor: '#FFFFFF',\n            strokeWeight: 1,\n            scale: 3,\n            rotation: vessel.heading || 0,\n          }}\n          onClick={() => setSelectedVessel(vessel)}\n        />\n      );\n    });\n  }, [vessels, setSelectedVessel]);\n  \n  // Simple implementations of other render functions\n  const renderWindFarms = useCallback(() => {\n    console.log(\"Rendering wind farms\");\n    return null; // Simplified, no wind farms\n  }, []);\n  \n  const renderRadarCoverage = useCallback(() => {\n    console.log(\"Rendering radar coverage\");\n    return null; // Simplified\n  }, []);\n  \n  const renderVesselRadarCoverage = useCallback(() => {\n    console.log(\"Rendering vessel radar coverage\");\n    return null; // Simplified\n  }, []);\n  \n  // Memoize UI elements that don't need frequent updates\n  const controlPanels = useMemo(() => (\n    <>\n      <div style={styles.controlPanel}>\n        <h2 style={styles.heading}>Display Controls</h2>\n        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>\n          <button \n            style={showVesselRadar ? {...styles.buttonActive, backgroundColor: '#2563EB'} : styles.button}\n            onClick={() => setShowVesselRadar(!showVesselRadar)}\n          >\n            <Radar size={16} style={{ marginRight: '8px' }} />\n            {showVesselRadar ? 'Hide Vessel Radar' : 'Show Vessel Radar'}\n          </button>\n          \n          <button \n            style={simulationEnabled ? {...styles.buttonActive, backgroundColor: '#16A34A'} : styles.button}\n            onClick={() => setSimulationEnabled(!simulationEnabled)}\n          >\n            <Ship size={16} style={{ marginRight: '8px' }} />\n            {simulationEnabled ? 'Stop Movement' : 'Simulate Movement'}\n          </button>\n          \n          <button \n            style={seaMeshSimulationEnabled ? \n              {...styles.buttonActive, backgroundColor: '#D97706'} : \n              {...styles.button, backgroundColor: '#B45309'}\n            }\n            onClick={() => setSeaMeshSimulationEnabled(!seaMeshSimulationEnabled)}\n          >\n            <Radar size={16} style={{ marginRight: '8px' }} />\n            {seaMeshSimulationEnabled ? 'Stop SeaMesh' : 'Simulate SeaMesh'}\n          </button>\n        </div>\n      </div>\n    </>\n  ), [showVesselRadar, simulationEnabled, seaMeshSimulationEnabled]);\n  \n  // Simple function to render sea mesh simulation\n  const renderSeaMeshSimulation = useCallback(() => {\n    console.log(\"Rendering SeaMesh simulation\");\n    \n    // Mock data for demonstration\n    const seaMeshPoints = [\n      { lat: 59.5, lng: 20.5 }, \n      { lat: 60.0, lng: 21.0 },\n      { lat: 59.8, lng: 21.5 },\n      { lat: 59.3, lng: 21.2 },\n    ];\n    \n    return (\n      <>\n        {seaMeshPoints.map((point, index) => (\n          <Circle\n            key={`seamesh-${index}`}\n            center={point}\n            radius={5000}\n            options={{\n              fillColor: '#3B82F6',\n              fillOpacity: 0.3,\n              strokeColor: '#2563EB',\n              strokeOpacity: 0.8,\n              strokeWeight: 1,\n            }}\n          />\n        ))}\n      </>\n    );\n  }, []);\n  \n  // Update UI to include display mode toggle\n  return (\n    <div style={styles.container}>\n      <div style={{ display: 'flex', flex: 1 }}>\n        {showSidebar && (\n          <div style={styles.sidebar}>\n            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '16px' }}>\n              <h1 style={{ fontSize: '20px', fontWeight: 'bold', color: '#3D85C6' }}>Baltic Sea Tracker</h1>\n              <button onClick={() => setShowSidebar(false)} style={{ background: 'none', border: 'none', color: '#888888', cursor: 'pointer' }}>\n                <Menu size={20} />\n              </button>\n            </div>\n            \n            {controlPanels}\n          </div>\n        )}\n\n        <div style={{ flex: 1, position: 'relative' }}>\n          {!showSidebar && (\n            <button\n              style={{ \n                position: 'absolute', \n                top: '16px', \n                left: '16px', \n                zIndex: 10, \n                backgroundColor: '#1F2937',\n                padding: '8px',\n                borderRadius: '4px',\n                border: 'none',\n                cursor: 'pointer'\n              }}\n              onClick={() => setShowSidebar(true)}\n            >\n              <Menu size={20} color=\"#D1D5DB\" />\n            </button>\n          )}\n          \n          {/* Simplified Google Maps integration */}\n          {loadError && (\n            <div className=\"w-full h-full flex flex-col items-center justify-center bg-gray-900 text-white p-4\">\n              <div className=\"text-xl mb-4\">Error loading Google Maps: {loadError.message}</div>\n            </div>\n          )}\n          \n          {isLoaded ? (\n            <GoogleMap\n              id=\"map\"\n              mapContainerStyle={styles.map}\n              center={mapCenter}\n              zoom={mapZoom}\n              options={mapOptions}\n              onLoad={onMapLoad}\n            >\n              {/* Only render essential components */}\n              {vessels.length > 0 && vessels.map(vessel => {\n                if (!vessel.position || vessel.position.length < 2) return null;\n                \n                const position = { lat: vessel.position[1], lng: vessel.position[0] };\n                \n                return (\n                  <MemoizedMarker\n                    key={vessel.id}\n                    position={position}\n                    icon={{\n                      path: \"M -1,1 L 1,1 L 1,-1 L -1,-1 Z\", // Simple square\n                      fillColor: vessel.isRussian ? 'rgb(231, 76, 60)' : 'rgb(52, 152, 219)',\n                      fillOpacity: 0.8,\n                      strokeColor: '#FFFFFF',\n                      strokeWeight: 1,\n                      scale: 3,\n                      rotation: vessel.heading || 0,\n                    }}\n                    onClick={() => setSelectedVessel(vessel)}\n                  />\n                );\n              })}\n              \n              {/* Render SeaMesh simulation only if enabled */}\n              {seaMeshSimulationEnabled && renderSeaMeshSimulation()}\n            </GoogleMap>\n          ) : (\n            <div style={{ \n              width: '100%', \n              height: '100%', \n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              backgroundColor: '#1F2937',\n              color: 'white'\n            }}>\n              <div style={{ fontSize: '20px' }}>Loading map...</div>\n            </div>\n          )}\n        </div>\n      </div>\n      \n      <div style={styles.footer}>\n        <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>\n          <Info size={16} style={{ marginRight: '4px', color: '#3B82F6' }} />\n          <span style={{ color: '#D1D5DB' }}>Baltic Sea Tracker - {vessels.length} vessels | Zoom: {currentZoom}</span>\n          {seaMeshSimulationEnabled && <span style={{ margin: '0 4px', color: '#F59E0B' }}>| SeaMesh Simulation Active</span>}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default BalticSeaTracker;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}